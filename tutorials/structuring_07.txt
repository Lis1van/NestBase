### Изменение структуры проекта

На данном этапе мы приступим к **реорганизации структуры нашего приложения**,
чтобы проект стал более организованным, а код — легко читаемым и поддерживаемым.
Начнем с удаления неиспользуемых файлов и создания новых модулей для упрощения доступа к различным частям приложения.

---

### 1. Удаление ненужных файлов

**Шаги:**

1. **Удаление файлов `app.controller.spec.ts` и `app.service.ts`:** Эти файлы были автоматически
созданы при инициализации проекта, но они не требуются для нашего проекта. Мы будем организовывать код так,
что **основной модуль** `AppModule` не будет содержать контроллеров и сервисов напрямую;
в дальнейшем мы подключим необходимые модули и предоставим доступ к функциональности через них.

   > _Примечание:_ Файл `app.controller.spec.ts` используется для тестирования контроллеров,
   а `app.service.ts` — для хранения логики, связанной с сервисами, но поскольку их функционал не нужен,
   мы можем удалить их для упрощения структуры.

---

### 2. Создание нового модуля для проверки состояния приложения

Чтобы организовать отдельный блок для проверки состояния приложения, создадим **HealthModule**,
который будет содержать необходимый функционал. Этот модуль позволит внешним сервисам проверить
работоспособность приложения.

**Шаги:**

1. **Создание модуля HealthModule** с помощью команды:
   ```bash
   nest generate module health
   ```
   Этот модуль будет отвечать за проверку состояния приложения и обрабатывать запросы для получения статуса работы.

2. **Создание контроллера в модуле HealthModule**:
   ```bash
   nest generate controller health
   ```
   Контроллер **HealthController** будет принимать запросы, проверяющие состояние приложения,
   и возвращать сообщение о его работоспособности.

   В результате, в нашем проекте будет создана структура, в которой `AppModule` не содержит
   собственных контроллеров и сервисов, но импортирует остальные модули.

**Пример кода для HealthController:**

```typescript
import { Controller, Get } from '@nestjs/common';

@Controller('health')
export class HealthController {
  @Get()
  checkHealth(): string {
    return 'App is healthy';
  }
}
```

> **Объяснение:** Метод `checkHealth` с аннотацией `@Get()` определяет GET-запрос, который возвращает
строку `"App is healthy"`. Этот метод может использоваться внешними системами для **периодической
проверки** состояния приложения.

**Пример кода для HealthModule:**

```typescript
import { Module } from '@nestjs/common';
import { HealthController } from './health.controller';

@Module({
  controllers: [HealthController],
})
export class HealthModule {}
```

> **Объяснение:** В этом модуле определяется `HealthController`, позволяющий приложению принимать и
обрабатывать запросы для проверки состояния. Подобные проверки часто используются в крупных системах
для мониторинга бэкенда и могут подключаться к инструментам мониторинга состояния приложения.

**Добавление HealthModule в главный модуль AppModule:**

```typescript
import { Module } from '@nestjs/common';
import { HealthModule } from './health/health.module';
import { UsersModule } from './users/users.module';

@Module({
  imports: [UsersModule, HealthModule],
  controllers: [],
  providers: [],
})
export class AppModule {}
```

> **Примечание:** Импорт `HealthModule` в `AppModule` позволяет приложению подключить модуль проверки состояния,
что повышает стабильность системы за счёт интеграции в общую инфраструктуру мониторинга.

---

### 3. Создание общей структуры модулей

Для повышения организованности создадим директорию `modules` и будем размещать там все модули.
Такой подход упрощает навигацию, особенно при увеличении объема приложения.

**Шаги:**

1. **Создание папки `modules`**:
   - Создаем директорию `modules` и переносим туда существующие модули `auth`, `health`, и `users`.

2. **Регистрация новых модулей в AppModule**:
   - При создании нового модуля NestJS автоматически добавляет его в `AppModule`, но иногда это не срабатывает,
   и путь нужно указывать вручную.

**Пример итогового кода AppModule:**

```typescript
import { Module } from '@nestjs/common';
import { AuthModule } from './modules/auth/auth.module';
import { HealthModule } from './modules/health/health.module';
import { UsersModule } from './modules/users/users.module';

@Module({
  imports: [UsersModule, HealthModule, AuthModule],
  controllers: [],
  providers: [],
})
export class AppModule {}
```

---

### 4. Работа с базой данных и сущностями

Создание и организация структуры базы данных являются важным шагом при разработке приложения.
В нашем проекте каждая сущность будет размещаться в соответствующих папках для улучшения навигации и
структурирования кода.

**Шаги:**

1. **Создание папки `database` для сущностей**:
   - Внутри папки `database` создаем директорию `entities` и перемещаем туда все сущности,
   такие как `auth.entity.ts` и `user.entity.ts`. Это обеспечит более понятную структуру данных,
   что упростит управление сущностями.

2. **Создание папки для миграций**:
   - Для автоматической работы с миграциями создаем папку `migrations` в `database`,
   которая позволит легко выполнять и отслеживать изменения в базе данных.

3. **Создание общей директории common**:
   - Создаем папку `common` и внутри неё размещаем общие компоненты: `guards`, `decorators`, `helpers`.
   Эти папки предназначены для хранения кода, который может использоваться во всем приложении:
   - **guards** — содержит файлы с логикой проверки доступа.
   - **decorators** — для различных декораторов, упрощающих написание повторяющегося кода.
   - **helpers** — вспомогательные файлы для общих задач, например, обработки ошибок.

---

### 5. Работа с DTO

**DTO** (Data Transfer Object) — это классы, используемые для передачи данных между компонентами приложения.
Организация DTO по модулям помогает поддерживать удобство работы с кодом.

**Шаги:**

1. **Создание папки для DTO в каждом модуле**:
   - В каждом модуле создается папка `dto` с поддиректориями `req` и `res`, где хранятся классы,
   соответствующие запросам и ответам, например, `create-user.dto.ts` и `user.response.dto.ts`.

2. **Создание директории `services` для хранения файлов сервисов**:
   - Внутри каждого модуля добавляем папку `services`, куда помещаем файлы сервисов, например,
   `users.service.ts`, `auth.service.ts`.

---

### Структура проекта после реорганизации

Вот пример структуры, которая у нас получилась на данном этапе:

```
node_modules
|src
|--common
|--|--decorators
|--|--guards
|--|--helpers
|--database
|--|--entities
|--|--|--auth.entity.ts
|--|--|--user.entity.ts
|--|--migrations
|--modules
|--|--auth
|--|--|--dto
|--|--|--|--req
|--|--|--|--res
|--|--|--services
|--|--|--auth.controller.ts
|--|--|--auth.module.ts
|--|--health
|--|--|--health.controller.ts
|--|--|--health.module.ts
|--|--users
|--|--|--dto
|--|--|--|--req
|--|--|--|--res
|--|--|--services
|--|--|--users.controller.ts
|--|--|--users.module.ts
|--app.module.ts
|--main.ts
test
```

---

**Заключение:** Мы сделали важные шаги в организации проекта, что упростит его расширение.
Такая структура позволяет добавлять новые модули и организовывать логику без перегруженности кода и структуры приложения.
