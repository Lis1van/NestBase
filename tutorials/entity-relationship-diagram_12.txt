 Введение в новый материал
Теперь, переходя к следующему этапу разработки приложения, мы рассмотрим создание ER-диаграмм для проектирования
 базы данных. Эти диаграммы помогают визуализировать связи между сущностями базы данных до начала разработки,
 что облегчает понимание архитектуры приложения и структуры данных.


Что такое ER-диаграмма?

ER-диаграмма (Entity-Relationship диаграмма) — это документ, который используется для проектирования базы данных.
Она помогает визуализировать, как различные сущности (таблицы) связаны между собой.

Пример структуры ER-диаграммы:
- Пользователь (User): Связан с сущностями, такими как Refresh Tokens, Посты, Фолловеры, Лайки и Комментарии.
- Пост (Post): Может иметь Комментарии и Теги, а также быть связанным с Лайками.

Виды связей в ER-диаграммах

Связи между сущностями бывают нескольких типов, и каждая из них имеет важное значение для проектирования:

1. Один-к-одному (1:1): Один объект может быть связан только с одним другим объектом.
Например, один пользователь может иметь один уникальный профиль.

2. Один-ко-многим (1:М): Один объект может быть связан с несколькими объектами.
Например, один пользователь может иметь несколько постов.

3. Многие-ко-многим (М:М): Один объект может быть связан с несколькими другими объектами, и наоборот.
Например, пользователь может лайкать несколько постов, и каждый пост может быть залайкан несколькими пользователями.

Пример связи "Один ко многим"
- Один пользователь может иметь несколько рефреш-токенов (1:М).
Например, у пользователя может быть несколько устройств, с которых он выполняет вход в систему.

User ---< Refresh Tokens

Пример связи "Многие ко многим"
- Один пользователь может лайкать несколько постов, и один пост может быть залайкан несколькими пользователями (М:М).

User >---< Post (Likes)


Поддержка и использование ER-диаграмм

ER-диаграммы играют важную роль в проектировании базы данных, но их поддержка и обновление могут быть сложными
в крупных проектах. Несмотря на это, они остаются полезным инструментом на этапе планирования,
так как помогают всем участникам команды понять структуру базы данных и связи между её сущностями.

Как ER-диаграммы используются в процессе разработки:
1. Документация структуры базы данных: Составляется до начала разработки для определения всех сущностей и их связей.
2. Поддержка целостности данных: Связи, обозначенные на диаграмме, помогают при реализации ограничений и отношений
в базе данных.
3. Навигация и расширение проекта: ER-диаграмма служит ориентиром для разработчиков и других участников команды,
помогая им легко вносить изменения в структуру базы данных по мере роста проекта.


Заключение

В этом уроке мы рассмотрели основы ER-диаграмм и их роль в проектировании базы данных.
Понимание связей между сущностями на ранних этапах разработки помогает избежать проблем с масштабированием
и поддержанием базы данных в будущем.
(надо полностью переписать эту часть с нормальным объяснением с документации с примерами диограм)
**Продолжение следует в следующем уроке**, где мы рассмотрим, как перейти от ER-диаграммы к практической
реализации базы данных в проекте NestJS.

Урок 14: Работа с реляциями в базе данных с использованием TypeORM

Введение

На предыдущем уроке мы изучили основные методы работы с базами данных в NestJS, а также создали базовую модель
для работы с пользователями. Сегодня мы углубимся в работу с реляционными связями в базе данных, используя TypeORM.
Мы разберём несколько типов связей и посмотрим, как их реализовать в нашем проекте.

Типы реляционных связей

Реляционные базы данных используют связи между таблицами для создания структурированных данных.
Основные типы связей в TypeORM:

1. One-to-One (Один к одному): Одна сущность связана с одной другой сущностью.
2. One-to-Many (Один ко многим) и Many-to-One (Многие к одному): Одна сущность может быть связана с множеством сущностей.
3. Many-to-Many (Многие ко многим): Множество сущностей могут быть связаны с множеством других сущностей
через промежуточную таблицу.

One-to-One (Один к одному)

Связь "Один к одному" используется, когда одна запись в одной таблице связана с одной записью в другой таблице.
Например, у пользователя может быть только один профиль. В TypeORM это реализуется с помощью декоратора `@OneToOne`.

Пример:

```typescript
@Entity()
export class Profile {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  bio: string;

  @OneToOne(() => User)
  @JoinColumn() // Определяет, с какой стороны будет храниться связь
  user: User;
}
```

Объяснение: В данном случае профиль связан с пользователем, и мы используем `@JoinColumn()`, чтобы указать,
что связь будет храниться на стороне профиля. Это означает, что профиль будет содержать ссылку на пользователя.

One-to-Many (Один ко многим) и Many-to-One (Многие к одному)

Эта связь часто используется, когда одна сущность может иметь несколько других.
Например, один пользователь может иметь много постов.

Пример :
Ссылка на таблицу с взаимосвязями https://app.diagrams.net/#Hfeden2906%2Fdemo-nestjs%2Fmaster%2FUntitled%20Diagram.drawio%23%7B%22pageId%22%3A%22C5RBs43oDa-KdzZeNtuy%22%7D
У нас уже есть user.entity.ts . Судя по тааблице связей нам надо создать ещё несколько и связать между собой.
Вот user.entity.ts

import {
  Column,
  CreateDateColumn,
  Entity,
  OneToMany,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';

import { ArticleEntity } from './article.entity';
import { CommentEntity } from './comment.entity';
import { FollowEntity } from './follow.entity';
import { LikeEntity } from './like.entity';
import { RefreshTokenEntity } from './refresh-token.entity';

@Entity('user')
export class UserEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('text')
  name: string;

  @Column('text')
  email: string;

  @Column('text')
  password: string;

  @Column('text')
  bio: string;

  @Column('text')
  image: string;

  @CreateDateColumn()
  created: Date;

  @UpdateDateColumn()
  updated: Date;

  @OneToMany(() => RefreshTokenEntity, (entity) => entity.user)
  refreshTokens: RefreshTokenEntity[];

  @OneToMany(() => ArticleEntity, (entity) => entity.user)
  articles: ArticleEntity[];

  @OneToMany(() => CommentEntity, (entity) => entity.user)
  comments: CommentEntity[];

  @OneToMany(() => LikeEntity, (entity) => entity.user)
  likes: LikeEntity[];

  @OneToMany(() => FollowEntity, (entity) => entity.follower)
  followers?: FollowEntity[];

  @OneToMany(() => FollowEntity, (entity) => entity.following)
  followings?: FollowEntity[];
}

Теперь создадим ещё одну сущность refresh-token.entity.ts и свяжем её с остальными как указано в таблице:

import {
  Column,
  CreateDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';

import { UserEntity } from './user.entity';

@Entity('refresh-token')
export class RefreshTokenEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @Column('text')
  refreshToken: string;

  @Column('text')
  deviceId: string;

  @Column()
  user_id: string;
  @ManyToOne(() => UserEntity, (entity) => entity.refreshTokens)
  @JoinColumn({ name: 'user_id' })
  user: UserEntity;
}

Теперь создадим ещё одну сущность article.entity.ts и свяжем её с остальными как указано в таблице:

import {
  Column,
  CreateDateColumn,
  Entity,
  JoinColumn,
  JoinTable,
  ManyToMany,
  ManyToOne,
  OneToMany,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';

import { CommentEntity } from './comment.entity';
import { LikeEntity } from './like.entity';
import { TagEntity } from './tag.entity';
import { UserEntity } from './user.entity';

@Entity('article')
export class ArticleEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @CreateDateColumn()
  created: Date;

  @UpdateDateColumn()
  updated: Date;

  @Column('text')
  title: string;

  @Column('text')
  description: string;

  @Column('text')
  body: string;

  @Column()
  user_id: string;
  @ManyToOne(() => UserEntity, (entity) => entity.articles)
  @JoinColumn({ name: 'user_id' })
  user: UserEntity;

  @OneToMany(() => CommentEntity, (entity) => entity.articles)
  comments: CommentEntity[];

  @OneToMany(() => LikeEntity, (entity) => entity.articles)
  likes: LikeEntity[];

  @ManyToMany(() => TagEntity, (entity) => entity.articles)
  @JoinTable()
  tags: TagEntity[];
}

Теперь создадим ещё одну сущность comment.entity.ts и свяжем её с остальными как указано в таблице:

import {
  Column,
  CreateDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';

import { ArticleEntity } from './article.entity';
import { UserEntity } from './user.entity';

@Entity('comments')
export class CommentEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @CreateDateColumn()
  created: Date;

  @UpdateDateColumn()
  updated: Date;

  @Column('text')
  body: string;

  @Column()
  user_id: string;
  @ManyToOne(() => UserEntity, (entity) => entity.comments)
  @JoinColumn({ name: 'user_id' })
  user: UserEntity;

  @Column()
  article_id: string;
  @ManyToOne(() => ArticleEntity, (entity) => entity.comments)
  @JoinColumn({ name: 'article_id' })
  articles: ArticleEntity;
}

Теперь создадим ещё одну сущность like.entity.ts и свяжем её с остальными как указано в таблице:

import {
  Column,
  CreateDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';

import { ArticleEntity } from './article.entity';
import { UserEntity } from './user.entity';

@Entity('like')
export class LikeEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @CreateDateColumn()
  created: Date;

  @UpdateDateColumn()
  updated: Date;

  @Column()
  user_id: string;
  @ManyToOne(() => UserEntity, (entity) => entity.likes)
  @JoinColumn({ name: 'user_id' })
  user: UserEntity;

  @Column()
  article_id: string;
  @ManyToOne(() => ArticleEntity, (entity) => entity.likes)
  @JoinColumn({ name: 'article_id' })
  articles: ArticleEntity;
}

Теперь создадим ещё одну сущность follow.entity.ts и свяжем её с остальными как указано в таблице:

import {
  Column,
  CreateDateColumn,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';

import { UserEntity } from './user.entity';

@Entity('follow')
export class FollowEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @CreateDateColumn()
  created: Date;

  @UpdateDateColumn()
  updated: Date;

  @Column()
  follower_id: string;
  @ManyToOne(() => UserEntity, (entity) => entity.followers)
  @JoinColumn({ name: 'follower_id' })
  follower?: UserEntity;

  @Column()
  following_id: string;
  @ManyToOne(() => UserEntity, (entity) => entity.followings)
  @JoinColumn({ name: 'following_id' })
  following?: UserEntity;
}


Объяснение: В этом примере, один пользователь может иметь несколько постов, а каждый пост принадлежит только
одному пользователю. Здесь `@OneToMany` используется на стороне пользователя, а `@ManyToOne` — на стороне поста.
(добавить описание каждого кода и полное обьяснение как это работает)

Many-to-Many (Многие ко многим)

Связь "Многие ко многим" позволяет нескольким сущностям быть связанными с несколькими другими.
Например, статьи могут иметь множество тегов, и теги могут быть связаны с множеством статей.

Пример:
Теперь создадим ещё одну сущность tag.entity.ts и свяжем её с остальными как указано в таблице:

import {
  Column,
  CreateDateColumn,
  Entity,
  JoinTable,
  ManyToMany,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';

import { ArticleEntity } from './article.entity';

@Entity('tags')
export class TagEntity {
  @PrimaryGeneratedColumn('uuid')
  id: number;

  @CreateDateColumn()
  created: Date;

  @UpdateDateColumn()
  updated: Date;

  @Column('text')
  name: string;

  @ManyToMany(() => ArticleEntity, (entity) => entity.tags)
  @JoinTable()
  articles: ArticleEntity[];
}

Объяснение: В данном примере используется `@ManyToMany`, и связь между статьями и тегами управляется промежуточной
таблицей, которая создаётся автоматически за счёт декоратора `@JoinTable()`.


Создание миграций

После того как мы описали связи в сущностях, нам необходимо сгенерировать миграции для обновления структуры базы данных.

Скрипты, в нашем случае, для работы с миграциями:

"migration:generate": "cross-var npm run typeorm -- migration:generate ./src/database/migrations/$npm_config_name",

За тем запускаем миграции:

"migration:run": "npm run typeorm -- migration:run"


Эти команды создадут и применят миграцию, обновив структуру таблиц в базе данных.

Заключение

В этом уроке мы разобрали основные типы реляционных связей в базе данных и научились реализовывать их с
использованием TypeORM в NestJS. Мы создали связи "Один ко многим", "Многие к одному" и "Многие ко многим",
а также научились работать с миграциями для обновления базы данных.

///////////////////////////////////

Ещё больше информации:
## Глава 1: Введение в ER-диаграммы и основные типы связей

**ER-диаграммы (Entity-Relationship Diagram)** помогают визуализировать структуру базы данных.
 В центре любой ER-диаграммы находятся:
1. **Сущности (Entities)** — представляют таблицы в базе данных, например, `User`, `Order`, `Product`.
2. **Связи (Relationships)** — определяют, как сущности связаны между собой. Основные типы связей включают:
   - **"Один к одному" (One-to-One)**
   - **"Один ко многим" (One-to-Many)**
   - **"Многие ко многим" (Many-to-Many)**

### 1. Что такое ER-диаграмма?

ER-диаграмма помогает наглядно представить, как данные будут структурированы и связаны в базе данных.
Каждая сущность имеет атрибуты — это данные, которые описывают данную сущность.
Например, `User` может иметь атрибуты `id`, `name`, `email`, `createdAt`.

**Зачем нужны ER-диаграммы?**
- Они помогают на этапе проектирования базы данных — легче понять, как данные будут связаны.
- Упрощают объяснение структуры базы данных другим разработчикам.
- Помогают избежать дублирования данных и логических ошибок.

### 2. Типы связей и их использование

Теперь перейдем к основным типам связей и обсудим их реализацию с примерами кода.

#### Связь "Один к одному" (One-to-One)

Связь "Один к одному" означает, что каждая запись в одной таблице связана только с одной записью в другой.
Пример: у пользователя `User` может быть только один `Profile`.

1. **ER-диаграмма связи "Один к одному"**

   ```plaintext
   User ----- Profile
   ```

2. **Реализация в TypeORM**

   Создадим две сущности, `User` и `Profile`, и установим связь "Один к одному":

   ```typescript
   // user.entity.ts
   import { Entity, PrimaryGeneratedColumn, Column, OneToOne, JoinColumn } from 'typeorm';
   import { Profile } from './profile.entity';

   @Entity()
   export class User {
     @PrimaryGeneratedColumn()
     id: number;

     @Column()
     name: string;

     @OneToOne(() => Profile)
     @JoinColumn()
     profile: Profile;
   }
   ```

   ```typescript
   // profile.entity.ts
   import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

   @Entity()
   export class Profile {
     @PrimaryGeneratedColumn()
     id: number;

     @Column()
     bio: string;

     @Column()
     avatarUrl: string;
   }
   ```

**Объяснение кода:**
- Мы используем декоратор `@OneToOne`, чтобы указать, что у `User` может быть только один `Profile`.
- Декоратор `@JoinColumn` связывает `User` и `Profile`, создавая внешний ключ.

#### Связь "Один ко многим" (One-to-Many)

Связь "Один ко многим" означает, что одна запись в одной таблице может быть связана с несколькими записями в другой.
 Пример: один `User` может иметь несколько `Order`.

1. **ER-диаграмма связи "Один ко многим"**

   ```plaintext
   User -----< Order
   ```

2. **Реализация в TypeORM**

   Теперь создадим связь между `User` и `Order`:

   ```typescript
   // user.entity.ts
   import { Entity, PrimaryGeneratedColumn, Column, OneToMany } from 'typeorm';
   import { Order } from './order.entity';

   @Entity()
   export class User {
     @PrimaryGeneratedColumn()
     id: number;

     @Column()
     name: string;

     @OneToMany(() => Order, (order) => order.user)
     orders: Order[];
   }
   ```

   ```typescript
   // order.entity.ts
   import { Entity, PrimaryGeneratedColumn, Column, ManyToOne } from 'typeorm';
   import { User } from './user.entity';

   @Entity()
   export class Order {
     @PrimaryGeneratedColumn()
     id: number;

     @Column()
     item: string;

     @Column('decimal')
     price: number;

     @ManyToOne(() => User, (user) => user.orders)
     user: User;
   }
   ```

**Объяснение кода:**
- `@OneToMany` в `User` показывает, что у пользователя может быть много заказов.
- `@ManyToOne` в `Order` показывает, что каждый заказ принадлежит одному пользователю.

#### Связь "Многие ко многим" (Many-to-Many)

Связь "Многие ко многим" означает, что несколько записей в одной таблице могут быть связаны с несколькими
записями в другой. Пример: один `Product` может быть включен в несколько `Category`, и одна `Category` может
включать несколько `Product`.

1. **ER-диаграмма связи "Многие ко многим"**

   ```plaintext
   Product -----< Category >----- Product
   ```

2. **Реализация в TypeORM**

   Создадим связь между `Product` и `Category`:

   ```typescript
   // product.entity.ts
   import { Entity, PrimaryGeneratedColumn, Column, ManyToMany, JoinTable } from 'typeorm';
   import { Category } from './category.entity';

   @Entity()
   export class Product {
     @PrimaryGeneratedColumn()
     id: number;

     @Column()
     name: string;

     @ManyToMany(() => Category, (category) => category.products)
     @JoinTable()
     categories: Category[];
   }
   ```

   ```typescript
   // category.entity.ts
   import { Entity, PrimaryGeneratedColumn, Column, ManyToMany } from 'typeorm';
   import { Product } from './product.entity';

   @Entity()
   export class Category {
     @PrimaryGeneratedColumn()
     id: number;

     @Column()
     name: string;

     @ManyToMany(() => Product, (product) => product.categories)
     products: Product[];
   }
   ```

**Объяснение кода:**
- `@ManyToMany` в `Product` и `Category` показывает связь между сущностями.
- `@JoinTable` добавлен в `Product` для создания промежуточной таблицы, которая хранит связи
между `Product` и `Category`.

---

Это базовое введение в типы связей и их реализацию в TypeORM. Теперь можно двигаться к **созданию миграций**,
чтобы записывать эти изменения в базу данных.

Отлично, продолжим с тем, как создать миграции для этих сущностей, чтобы отразить изменения в базе данных.
Это позволит фиксировать структуру и связи, которые мы описали в предыдущем разделе.

---

## Глава 2: Создание миграций для сущностей и связей

**Миграции** — это файлы, которые описывают изменения структуры базы данных, такие как создание таблиц,
добавление колонок и связей между ними. В TypeORM миграции позволяют управлять изменениями в базе данных и
удобно переносить их на другие среды, например, на продакшен.

### Шаг 1: Настройка миграций в TypeORM

Для начала нужно убедиться, что проект настроен для работы с миграциями. В `TypeORM` можно использовать
команду CLI для генерации и запуска миграций.

**Пример конфигурации `typeorm.config.ts` для миграций**:

1. Убедитесь, что в вашем `typeorm.config.ts` файл настроен на использование миграций.

   ```typescript
   import { DataSource } from 'typeorm';
   import { User } from './entities/user.entity';
   import { Profile } from './entities/profile.entity';
   import { Order } from './entities/order.entity';
   import { Product } from './entities/product.entity';
   import { Category } from './entities/category.entity';

   export const AppDataSource = new DataSource({
     type: 'postgres',
     host: 'localhost',
     port: 5432,
     username: 'your_username',
     password: 'your_password',
     database: 'your_database',
     entities: [User, Profile, Order, Product, Category],
     migrations: ['src/migrations/*.ts'],
   });
   ```

   В этой конфигурации:
   - Указаны все наши сущности.
   - Путь к файлам миграций (`migrations: ['src/migrations/*.ts']`).

### Шаг 2: Генерация миграции

После настройки можно создать миграции с помощью команды:

```bash
npx typeorm migration:generate -d src/migrations -n InitialMigration
```

**Описание команды**:
- `migration:generate` — создает миграцию, которая автоматически фиксирует все изменения в схемах, описанных сущностями.
- `-d src/migrations` — путь к папке, где будут храниться миграции.
- `-n InitialMigration` — название миграции, например, `InitialMigration`.

Эта команда создаст файл миграции, который будет содержать инструкции по созданию всех наших таблиц и их связей.

### Шаг 3: Пример миграционного файла

Файл миграции может выглядеть примерно так:

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';

export class InitialMigration implements MigrationInterface {
   name = 'InitialMigration';

   public async up(queryRunner: QueryRunner): Promise<void> {
     await queryRunner.query(`
       CREATE TABLE "user" (
         "id" SERIAL NOT NULL,
         "name" character varying NOT NULL,
         CONSTRAINT "PK_cace4a159ff9f2512dd42373760" PRIMARY KEY ("id")
       );
     `);

     await queryRunner.query(`
       CREATE TABLE "profile" (
         "id" SERIAL NOT NULL,
         "bio" character varying NOT NULL,
         "avatarUrl" character varying NOT NULL,
         CONSTRAINT "PK_3dd8bfc97e4a77c70971591bdcb" PRIMARY KEY ("id")
       );
     `);

     await queryRunner.query(`
       CREATE TABLE "order" (
         "id" SERIAL NOT NULL,
         "item" character varying NOT NULL,
         "price" decimal NOT NULL,
         "userId" integer,
         CONSTRAINT "PK_1031171c13130102495201e3e20" PRIMARY KEY ("id")
       );
     `);

     await queryRunner.query(`
       CREATE TABLE "product" (
         "id" SERIAL NOT NULL,
         "name" character varying NOT NULL,
         CONSTRAINT "PK_a5e3358bfe6d2b5edb41d9fc7f0" PRIMARY KEY ("id")
       );
     `);

     await queryRunner.query(`
       CREATE TABLE "category" (
         "id" SERIAL NOT NULL,
         "name" character varying NOT NULL,
         CONSTRAINT "PK_24dbc6126a28ff948da33e97d3b" PRIMARY KEY ("id")
       );
     `);

     await queryRunner.query(`
       ALTER TABLE "order" ADD CONSTRAINT "FK_839a7a0e235b579ef74b99ae52b" FOREIGN KEY ("userId") REFERENCES "user"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
     `);

     await queryRunner.query(`
       CREATE TABLE "product_categories_category" (
         "productId" integer NOT NULL,
         "categoryId" integer NOT NULL,
         CONSTRAINT "PK_25f3dc34e610d6a19c0869cf278" PRIMARY KEY ("productId", "categoryId")
       );
     `);

     await queryRunner.query(`
       ALTER TABLE "product_categories_category" ADD CONSTRAINT "FK_2211ff8b7607a8e9406b35a41d1" FOREIGN KEY ("productId") REFERENCES "product"("id") ON DELETE CASCADE;
     `);

     await queryRunner.query(`
       ALTER TABLE "product_categories_category" ADD CONSTRAINT "FK_9ae6db62e478cf26dc3492541d2" FOREIGN KEY ("categoryId") REFERENCES "category"("id") ON DELETE CASCADE;
     `);
   }

   public async down(queryRunner: QueryRunner): Promise<void> {
     await queryRunner.query(`ALTER TABLE "product_categories_category" DROP CONSTRAINT "FK_9ae6db62e478cf26dc3492541d2"`);
     await queryRunner.query(`ALTER TABLE "product_categories_category" DROP CONSTRAINT "FK_2211ff8b7607a8e9406b35a41d1"`);
     await queryRunner.query(`ALTER TABLE "order" DROP CONSTRAINT "FK_839a7a0e235b579ef74b99ae52b"`);
     await queryRunner.query(`DROP TABLE "product_categories_category"`);
     await queryRunner.query(`DROP TABLE "category"`);
     await queryRunner.query(`DROP TABLE "product"`);
     await queryRunner.query(`DROP TABLE "order"`);
     await queryRunner.query(`DROP TABLE "profile"`);
     await queryRunner.query(`DROP TABLE "user"`);
   }
}
```

### Шаг 4: Применение миграций

После создания миграций можно их применить, чтобы структура базы данных обновилась в соответствии с миграциями.
Используйте следующую команду:

```bash
npx typeorm migration:run
```

### Шаг 5: Откат миграций

Если необходимо откатить изменения, выполните команду:

```bash
npx typeorm migration:revert
```

Эта команда отменит последнюю миграцию. Это удобно, если, например, вы заметили ошибку в структуре базы данных
 и хотите ее исправить.

---

На этом этапе у нас есть:
- Конфигурация базы данных и миграции.
- Таблицы и связи между ними, отраженные в ER-диаграмме, созданы в базе данных.

**Следующие шаги** могут включать добавление более сложной логики, использование транзакций и обработку
ошибок для повышения устойчивости системы при миграциях.

Отлично, теперь, когда у нас есть миграции и мы создали необходимые таблицы и связи в базе данных,
рассмотрим следующий важный аспект работы с миграциями — **обработку ошибок и использование транзакций**.
Эти инструменты помогут обеспечить стабильность базы данных и сделать процесс миграции более надежным,
особенно при внесении сложных изменений в структуру.

---

## Глава 3: Обработка ошибок и транзакции в миграциях

В процессе миграций могут возникнуть ошибки, связанные с синтаксическими ошибками, неверными типами данных,
нарушением целостности данных и другими проблемами. Использование **транзакций** позволяет нам откатить все изменения,
если возникнет ошибка. Это помогает избежать неполного применения миграции, что может привести к неконсистентному
состоянию базы данных.

### Что такое транзакция?

**Транзакция** — это набор операций с базой данных, которые выполняются как единое целое.
Если одна из операций транзакции завершится неудачей, все изменения, внесенные этой транзакцией, будут отменены.
Это гарантирует, что либо все операции внутри транзакции будут выполнены успешно, либо ни одна из них не будет применена.

### Применение транзакций в миграциях

В TypeORM можно использовать транзакции при написании миграций, чтобы защитить базу данных от некорректных изменений.
Давайте рассмотрим, как это можно сделать на примере нашей миграции.

### Шаг 1: Обертывание миграций в транзакции

Чтобы использовать транзакции в миграции, можно модифицировать метод `up` так, чтобы он выполнялся внутри транзакции.
Для этого используется объект `QueryRunner`, который позволяет управлять транзакцией.

### Пример миграции с транзакцией

Рассмотрим пример миграции с использованием транзакции для создания таблиц и связей:

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';

export class InitialMigrationWithTransactions implements MigrationInterface {
  name = 'InitialMigrationWithTransactions';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.startTransaction(); // Начало транзакции

    try {
      await queryRunner.query(`
        CREATE TABLE "user" (
          "id" SERIAL NOT NULL,
          "name" character varying NOT NULL,
          CONSTRAINT "PK_cace4a159ff9f2512dd42373760" PRIMARY KEY ("id")
        );
      `);

      await queryRunner.query(`
        CREATE TABLE "profile" (
          "id" SERIAL NOT NULL,
          "bio" character varying NOT NULL,
          "avatarUrl" character varying NOT NULL,
          CONSTRAINT "PK_3dd8bfc97e4a77c70971591bdcb" PRIMARY KEY ("id")
        );
      `);

      await queryRunner.query(`
        CREATE TABLE "order" (
          "id" SERIAL NOT NULL,
          "item" character varying NOT NULL,
          "price" decimal NOT NULL,
          "userId" integer,
          CONSTRAINT "PK_1031171c13130102495201e3e20" PRIMARY KEY ("id")
        );
      `);

      await queryRunner.query(`
        CREATE TABLE "product" (
          "id" SERIAL NOT NULL,
          "name" character varying NOT NULL,
          CONSTRAINT "PK_a5e3358bfe6d2b5edb41d9fc7f0" PRIMARY KEY ("id")
        );
      `);

      await queryRunner.query(`
        CREATE TABLE "category" (
          "id" SERIAL NOT NULL,
          "name" character varying NOT NULL,
          CONSTRAINT "PK_24dbc6126a28ff948da33e97d3b" PRIMARY KEY ("id")
        );
      `);

      await queryRunner.query(`
        ALTER TABLE "order" ADD CONSTRAINT "FK_839a7a0e235b579ef74b99ae52b" FOREIGN KEY ("userId") REFERENCES "user"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;
      `);

      await queryRunner.query(`
        CREATE TABLE "product_categories_category" (
          "productId" integer NOT NULL,
          "categoryId" integer NOT NULL,
          CONSTRAINT "PK_25f3dc34e610d6a19c0869cf278" PRIMARY KEY ("productId", "categoryId")
        );
      `);

      await queryRunner.query(`
        ALTER TABLE "product_categories_category" ADD CONSTRAINT "FK_2211ff8b7607a8e9406b35a41d1" FOREIGN KEY ("productId") REFERENCES "product"("id") ON DELETE CASCADE;
      `);

      await queryRunner.query(`
        ALTER TABLE "product_categories_category" ADD CONSTRAINT "FK_9ae6db62e478cf26dc3492541d2" FOREIGN KEY ("categoryId") REFERENCES "category"("id") ON DELETE CASCADE;
      `);

      await queryRunner.commitTransaction(); // Завершение транзакции

    } catch (error) {
      await queryRunner.rollbackTransaction(); // Откат транзакции при ошибке
      throw error; // Перевыброс ошибки для логирования или дополнительной обработки
    } finally {
      await queryRunner.release(); // Освобождение QueryRunner после завершения транзакции
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.startTransaction();

    try {
      await queryRunner.query(`ALTER TABLE "product_categories_category" DROP CONSTRAINT "FK_9ae6db62e478cf26dc3492541d2"`);
      await queryRunner.query(`ALTER TABLE "product_categories_category" DROP CONSTRAINT "FK_2211ff8b7607a8e9406b35a41d1"`);
      await queryRunner.query(`ALTER TABLE "order" DROP CONSTRAINT "FK_839a7a0e235b579ef74b99ae52b"`);
      await queryRunner.query(`DROP TABLE "product_categories_category"`);
      await queryRunner.query(`DROP TABLE "category"`);
      await queryRunner.query(`DROP TABLE "product"`);
      await queryRunner.query(`DROP TABLE "order"`);
      await queryRunner.query(`DROP TABLE "profile"`);
      await queryRunner.query(`DROP TABLE "user"`);

      await queryRunner.commitTransaction();

    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }
}
```

### Объяснение работы кода

1. **`queryRunner.startTransaction()`** — начинает транзакцию. С этого момента любые изменения в базе данных
будут считаться частью транзакции.
2. **Операции создания таблиц и связей** — выполняются внутри блока `try`.
3. **`queryRunner.commitTransaction()`** — завершает транзакцию, сохраняя все изменения в базе данных,
если они прошли успешно.
4. **Обработка ошибок (`catch` блок)** — если возникает ошибка, выполняется `queryRunner.rollbackTransaction()`,
который отменяет все изменения, сделанные внутри транзакции.
5. **`queryRunner.release()`** — освобождает ресурсы QueryRunner после выполнения миграции.

### Шаг 2: Запуск миграции с транзакцией

Запустите миграцию, как и раньше, используя команду:

```bash
npx typeorm migration:run
```

Если миграция будет успешно выполнена, изменения останутся в базе данных. Если возникнет ошибка, транзакция отменится,
и база данных останется в исходном состоянии.

### Зачем нужны транзакции в миграциях?

1. **Целостность данных** — транзакции предотвращают появление некорректного состояния базы данных в случае,
если часть миграции завершилась неудачей.
2. **Упрощение отладки** — благодаря откату изменений можно легко исправить ошибку и повторить миграцию.
3. **Безопасность** — при использовании транзакций вы защищаете базу данных от непредвиденных сбоев и ошибок
в коде миграции.

---

На этом этапе наше руководство включает:

1. **Создание и настройка миграций для сущностей и связей**.
2. **Использование транзакций и обработка ошибок для защиты базы данных**.

Хорошо, теперь, когда мы изучили основные принципы транзакций и обработки ошибок в миграциях,
давайте перейдем к более сложным и практическим сценариям миграций.
В реальных проектах базы данных со временем требуют изменений структуры, например, добавления или удаления столбцов,
пересмотра типов данных, а также применения новых ограничений. Рассмотрим, как реализовать такие изменения
и на что обратить внимание, чтобы миграции оставались стабильными и безопасными.

---

## Глава 4: Миграции при изменении структуры данных и лучшие практики

### Обзор изменений структуры данных

С течением времени требования к базе данных могут меняться. В этом случае могут возникнуть задачи по изменению
структуры таблиц:

1. **Добавление новых столбцов** — нужно, если необходимо сохранить новые данные.
2. **Удаление столбцов** — при отказе от ненужной информации.
3. **Изменение типа данных** — например, увеличение длины строкового типа.
4. **Применение новых ограничений и индексов** — для улучшения целостности данных и производительности.

### Пример 1: Добавление новых столбцов

Рассмотрим ситуацию, когда нужно добавить новый столбец, например, `email` в таблицу `user`.
Такой столбец, возможно, понадобится для регистрации и уведомлений пользователей.

**Пример миграции для добавления столбца:**

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddEmailColumnToUserTable implements MigrationInterface {
  name = 'AddEmailColumnToUserTable';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      ALTER TABLE "user"
      ADD "email" character varying UNIQUE NOT NULL;
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      ALTER TABLE "user"
      DROP COLUMN "email";
    `);
  }
}
```

### Объяснение работы кода

1. **ALTER TABLE** — используется для модификации структуры таблицы.
2. **ADD "email"** — добавляет новый столбец с типом `character varying`, устанавливая его уникальным (`UNIQUE`) и
обязательным (`NOT NULL`).
3. **Откат миграции (`down` метод)** — если нужно вернуть изменения, колонка `email` будет удалена
командой `DROP COLUMN`.

### Пример 2: Изменение типа данных столбца

Представьте, что текущая длина строкового столбца `name` в таблице `user` ограничена,
и нужно увеличить его до 255 символов.

**Пример миграции для изменения типа данных:**

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';

export class UpdateNameColumnTypeInUserTable implements MigrationInterface {
  name = 'UpdateNameColumnTypeInUserTable';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      ALTER TABLE "user"
      ALTER COLUMN "name" TYPE character varying(255);
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      ALTER TABLE "user"
      ALTER COLUMN "name" TYPE character varying(100); -- возвращение к предыдущей длине
    `);
  }
}
```

### Пример 3: Удаление столбца

Если бизнес-логика изменится, и, например, столбец `bio` в таблице `profile` больше не нужен, его можно удалить.

**Пример миграции для удаления столбца:**

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';

export class RemoveBioColumnFromProfileTable implements MigrationInterface {
  name = 'RemoveBioColumnFromProfileTable';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      ALTER TABLE "profile"
      DROP COLUMN "bio";
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      ALTER TABLE "profile"
      ADD "bio" character varying NOT NULL; -- восстановление удаленного столбца
    `);
  }
}
```

### Лучшие практики при внесении изменений в структуру данных

1. **Проверка обратной совместимости** — при создании миграций учитывайте, что в продакшн-среде миграции
могут выполняться параллельно с запросами к базе данных. Поэтому старайтесь, чтобы изменения не ломали
существующие функции.
2. **Создание миграций для удаления данных с предосторожностью** — если необходимо удалить столбцы или таблицы,
обязательно убедитесь, что в системе нет зависимостей от этих данных.
3. **Добавление индексов при необходимости** — если новый столбец будет часто использоваться в поисковых запросах,
добавление индекса может повысить производительность.
4. **Тестирование миграций перед деплоем** — создайте копию базы данных и проверьте все миграции перед их
применением на рабочем сервере.

### Пример 4: Применение ограничений и индексов

В случае, если нужно добавить индекс к колонке `email` для повышения скорости поиска пользователя по email,
можно создать миграцию для индекса:

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddIndexToUserEmail implements MigrationInterface {
  name = 'AddIndexToUserEmail';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      CREATE INDEX "IDX_user_email" ON "user" ("email");
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      DROP INDEX "IDX_user_email";
    `);
  }
}
```

### Обработка конфликтов при миграциях

В крупных проектах может быть несколько разработчиков, и у каждого могут быть свои миграции.
Чтобы избежать конфликтов и обеспечить согласованность, следуйте следующим рекомендациям:

1. **Упорядочивание миграций по времени создания** — это позволяет избежать коллизий при выполнении миграций.
2. **Регулярное обновление базы данных в dev-среде** — это помогает обнаружить возможные конфликты на этапе разработки,
а не в продакшн-среде.
3. **Работа в рамках единой ветки для миграций** — помогает минимизировать возможность конфликтов и дублирования
изменений в базе данных.

---

### Заключение

На этом этапе руководство охватывает важные темы по работе с миграциями:

1. **Создание миграций для добавления, удаления и модификации столбцов**.
2. **Использование транзакций и обработка ошибок для стабильности базы данных**.
3. **Работа с индексами и ограничениями для оптимизации запросов**.
4. **Лучшая практика и советы для предотвращения конфликтов миграций в командной разработке**.

Миграции — это мощный инструмент для управления изменениями базы данных в процессе разработки.
Следуя этим рекомендациям, вы сможете легко поддерживать структуру базы данных в актуальном состоянии и
обеспечивать ее целостность на всех этапах разработки.

## Глава 5: Продвинутые техники работы с миграциями в продакшн-среде

В этой главе мы обсудим, как подходить к миграциям в продакшн-среде.
Продакшн-среда требует более строгого подхода к миграциям из-за риска потерять данные или сломать
функциональность приложения. Рассмотрим, как подготовить и выполнять миграции, чтобы минимизировать риски
и сохранить доступность данных.

### Общие принципы миграций в продакшн-среде

В продакшн-среде миграции должны быть спланированы и протестированы до их применения. Основные принципы работы:

1. **Тщательное тестирование** — перед выполнением миграции убедитесь, что она была протестирована в среде,
максимально приближенной к продакшн.
2. **Обратимость миграции** — каждая миграция должна быть обратимой, чтобы в случае ошибки ее можно было быстро откатить.
3. **Минимизация времени выполнения** — миграции должны выполняться быстро, чтобы снизить время,
в течение которого база данных может быть заблокирована.
4. **Безопасность данных** — необходимо гарантировать, что данные не будут потеряны во время миграций.

### Этап 1: Подготовка к миграциям в продакшн-среде

Прежде чем выполнять миграции в продакшн-среде, выполните следующие шаги:

1. **Создайте резервную копию базы данных** — это позволит восстановить данные в случае непредвиденных ошибок.
2. **Проверьте миграции в тестовой среде** — создайте копию продакшн-базы данных и протестируйте миграцию,
чтобы убедиться, что она не вызывает ошибок.
3. **Подготовьте план отката** — у вас должна быть четкая стратегия на случай, если миграция не пройдет успешно.

### Этап 2: Пошаговая реализация сложных миграций

В сложных случаях (например, когда удаляются столбцы с важной информацией) целесообразно выполнять миграции
в несколько этапов:

1. **Создание нового столбца** — сначала добавьте новый столбец и настройте логику, чтобы данные записывались
и в новый, и в старый столбцы.
2. **Копирование данных** — выполните миграцию, которая копирует данные из старого столбца в новый.
3. **Проверка целостности данных** — убедитесь, что данные корректно перенесены.
4. **Удаление старого столбца** — после всех проверок и если данные корректны, можно удалить старый столбец.

### Пример: Поэтапная миграция с переносом данных

Рассмотрим сценарий, когда требуется изменить название столбца `username` на `user_name` в таблице `user`.
Прямое изменение может нарушить логику приложения, поэтому безопаснее выполнить миграцию поэтапно.

1. **Шаг 1: Добавление нового столбца `user_name`**

   ```typescript
   import { MigrationInterface, QueryRunner } from 'typeorm';

   export class AddUserNameColumnToUserTable implements MigrationInterface {
     name = 'AddUserNameColumnToUserTable';

     public async up(queryRunner: QueryRunner): Promise<void> {
       await queryRunner.query(`
         ALTER TABLE "user"
         ADD COLUMN "user_name" character varying;
       `);
     }

     public async down(queryRunner: QueryRunner): Promise<void> {
       await queryRunner.query(`
         ALTER TABLE "user"
         DROP COLUMN "user_name";
       `);
     }
   }
   ```

2. **Шаг 2: Копирование данных из `username` в `user_name`**

   После добавления нового столбца можно создать миграцию, которая скопирует данные из старого столбца:

   ```typescript
   import { MigrationInterface, QueryRunner } from 'typeorm';

   export class CopyUsernameToUserNameColumn implements MigrationInterface {
     name = 'CopyUsernameToUserNameColumn';

     public async up(queryRunner: QueryRunner): Promise<void> {
       await queryRunner.query(`
         UPDATE "user"
         SET "user_name" = "username";
       `);
     }

     public async down(queryRunner: QueryRunner): Promise<void> {
       await queryRunner.query(`
         UPDATE "user"
         SET "username" = "user_name";
       `);
     }
   }
   ```

3. **Шаг 3: Обновление кода приложения**

   Теперь, когда данные продублированы, обновите код приложения, чтобы оно использовало `user_name`, а не `username`.

4. **Шаг 4: Удаление старого столбца `username`**

   После того как все проверено и в приложении используется только `user_name`, можно безопасно удалить старый столбец:

   ```typescript
   import { MigrationInterface, QueryRunner } from 'typeorm';

   export class RemoveOldUsernameColumn implements MigrationInterface {
     name = 'RemoveOldUsernameColumn';

     public async up(queryRunner: QueryRunner): Promise<void> {
       await queryRunner.query(`
         ALTER TABLE "user"
         DROP COLUMN "username";
       `);
     }

     public async down(queryRunner: QueryRunner): Promise<void> {
       await queryRunner.query(`
         ALTER TABLE "user"
         ADD COLUMN "username" character varying;
       `);
     }
   }
   ```

### Этап 3: Запуск миграций в продакшн-среде

1. **Запланируйте простой временной интервал** — если миграция может занять много времени или создать нагрузку,
лучше запланировать её выполнение в часы низкой нагрузки.
2. **Включите логирование** — запустите миграции с включенным логированием, чтобы иметь возможность отследить любые
ошибки или аномалии.
3. **Проверка результатов после миграции** — после выполнения миграции убедитесь, что структура данных соответствует
ожидаемой, и проверьте функциональность приложения.

### Заключение

Мы рассмотрели следующие аспекты миграций в продакшн-среде:

1. **Основные принципы безопасности и тестирования миграций в продакшн-среде**.
2. **Этапы выполнения сложных миграций** для минимизации рисков и сохранения целостности данных.
3. **Стратегии поэтапной миграции данных**, позволяющие менять структуру таблиц, не нарушая работоспособность приложения.

Миграции в продакшн-среде требуют особого внимания и тщательной подготовки, но, следуя этим рекомендациям, можно минимизировать риски и обеспечить стабильную работу базы данных.


## Глава 6: Интеграция миграций с CI/CD процессом

Эта глава посвящена тому, как автоматизировать процесс миграций базы данных с помощью CI/CD.
Интеграция миграций с CI/CD (Continuous Integration/Continuous Deployment) помогает разработчикам и командам
автоматически выполнять миграции на этапах сборки и развертывания, что упрощает процесс управления изменениями
и минимизирует человеческие ошибки.

### Зачем интегрировать миграции с CI/CD?

Интеграция миграций с CI/CD имеет несколько преимуществ:

1. **Автоматизация** — процесс миграций становится автоматическим и запускается при каждом деплое.
2. **Единый процесс** — это обеспечивает стандартизированный процесс развертывания базы данных и ее обновления.
3. **Повышение надёжности** — автоматизация уменьшает вероятность ошибок, возникающих при ручном выполнении миграций.
4. **Обратимость** — возможность быстро откатить изменения в случае проблем с миграцией.

### Настройка автоматических миграций

Для интеграции миграций с CI/CD необходимо подготовить:

1. **Скрипт для запуска миграций** — отдельный скрипт, который выполняет миграции через CLI TypeORM.
2. **Настройка среды** — в каждом окружении (development, staging, production) необходимо настроить доступ к базе данных.
3. **Конфигурация CI/CD** — добавление этапа миграций в CI/CD pipeline.

### Этап 1: Создание скрипта для миграций

Для запуска миграций через CLI TypeORM можно использовать команду:

```bash
typeorm migration:run -d path/to/data-source.js
```

Однако, чтобы сделать процесс более гибким, полезно создать отдельный скрипт для запуска миграций.
Например, добавьте в `package.json` новый скрипт:

```json
"scripts": {
  "migrate": "typeorm migration:run -d dist/data-source.js"
}
```

Теперь для выполнения миграций можно использовать команду:

```bash
npm run migrate
```

### Этап 2: Настройка переменных окружения для CI/CD

CI/CD сервисы (такие как GitHub Actions, GitLab CI, Jenkins, CircleCI) позволяют настраивать переменные окружения,
которые передаются приложению при запуске.

В конфигурации CI/CD укажите переменные окружения для доступа к базе данных:

```yaml
# Пример для GitHub Actions
env:
  DB_HOST: ${{ secrets.DB_HOST }}
  DB_PORT: ${{ secrets.DB_PORT }}
  DB_USERNAME: ${{ secrets.DB_USERNAME }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  DB_NAME: ${{ secrets.DB_NAME }}
```

**Важно:** убедитесь, что переменные окружения защищены и хранятся в секретах, особенно для продакшн-среды.

### Этап 3: Настройка CI/CD pipeline для запуска миграций

Добавьте в CI/CD pipeline этап, на котором будут выполняться миграции. Пример на GitHub Actions:

```yaml
# .github/workflows/deploy.yml

name: Deploy

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'

      - name: Install dependencies
        run: npm install

      - name: Build the project
        run: npm run build

      - name: Run migrations
        run: npm run migrate
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}

      - name: Deploy application
        # Добавьте команды для деплоя вашего приложения
        run: echo "Deploy application here"
```

В этом примере миграции выполняются после сборки проекта, но перед деплоем приложения.
Это позволяет сначала обновить базу данных, чтобы приложение могло работать с новой схемой данных сразу после деплоя.

### Этап 4: Управление откатами миграций

На случай ошибок или нестабильности в миграциях целесообразно настроить команду для отката миграций. Например:

```json
"scripts": {
  "migrate:revert": "typeorm migration:revert -d dist/data-source.js"
}
```

И в случае необходимости отката в CI/CD можно вызвать:

```bash
npm run migrate:revert
```

### Пример процесса CI/CD с поддержкой откатов

Если ваш процесс CI/CD поддерживает ручные действия (например, GitHub Actions с возможностью ручного запуска),
можно настроить ручной этап отката. Пример для GitHub Actions:

```yaml
# .github/workflows/deploy.yml

jobs:
  deploy:
    steps:
      # Стандартные шаги
      - name: Run migrations
        run: npm run migrate
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}

  rollback:
    if: ${{ github.event.inputs.rollback == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'

      - name: Run revert migrations
        run: npm run migrate:revert
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
```

В этом примере добавлен блок `rollback`, который выполняется, если входной параметр `rollback` установлен в `true`.
Это можно использовать для ручного отката миграций при обнаружении проблем в продакшн-среде.

### Заключение

Интеграция миграций с CI/CD делает процесс управления базой данных более надежным и автоматизированным,
позволяет команде разработчиков быстро внедрять изменения, минимизируя возможность ошибок.
В этом разделе мы рассмотрели:

1. **Создание скриптов миграции для автоматического запуска**.
2. **Настройка переменных окружения** для безопасного доступа к базе данных.
3. **Конфигурацию CI/CD pipeline**, включающего запуск миграций и откатов.

Автоматизированные миграции помогают упростить процесс разработки и поддержания стабильности в продакшн-среде.

**В следующей главе мы рассмотрим, как оптимизировать миграции для больших объемов данных и как избежать
возможных проблем с производительностью.**

---

## Глава 7: Оптимизация миграций для больших объёмов данных

Когда объём данных в базе начинает расти, выполнение миграций может замедляться и даже приводить к временным
простоям приложения. Эта глава рассмотрит техники оптимизации миграций и методы, которые помогают избежать
потенциальных проблем с производительностью.

### Зачем оптимизировать миграции?

Основные причины для оптимизации миграций заключаются в следующем:

1. **Снижение времени выполнения** — минимизация времени выполнения миграций уменьшает возможные простои.
2. **Снижение нагрузки на базу данных** — снижает влияние миграций на основную работу базы данных и предотвращает
замедление приложения.
3. **Повышение надёжности** — оптимизация снижает вероятность возникновения ошибок при миграциях в продакшн-среде.

### Техники оптимизации миграций

#### 1. Пакетная обработка данных (Batch Processing)

При обновлении больших объёмов данных лучше выполнять операции порциями, чтобы не перегружать базу данных.
Например, если нужно обновить большое количество записей, вместо одного запроса на обновление всех записей
можно разбить операцию на несколько запросов, обновляя по 1000 записей за раз.

Пример миграции с пакетной обработкой:

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';

export class BatchUpdateExample implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    const batchSize = 1000;
    let offset = 0;
    let rows;

    do {
      rows = await queryRunner.query(
        `SELECT * FROM my_table LIMIT ${batchSize} OFFSET ${offset}`
      );

      // Выполнение обновления для каждой записи
      for (const row of rows) {
        await queryRunner.query(
          `UPDATE my_table SET column = new_value WHERE id = ${row.id}`
        );
      }

      offset += batchSize;
    } while (rows.length > 0);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // Логика отката изменений
  }
}
```

Этот код выполняет обновления в пакетах по 1000 записей за раз, что снижает нагрузку на базу данных.

#### 2. Создание индексов

Добавление индексов перед выполнением миграций может значительно ускорить выборку и обновление данных.
Например, если миграция включает массовое обновление строк, выборка строк для обновления с индексом будет гораздо быстрее.

Пример создания индекса перед миграцией:

```typescript
await queryRunner.query(`CREATE INDEX idx_my_column ON my_table(my_column)`);
```

После завершения миграции индекс можно удалить, если он больше не нужен:

```typescript
await queryRunner.query(`DROP INDEX idx_my_column`);
```

#### 3. Использование транзакций

Транзакции позволяют откатить изменения, если миграция не прошла успешно. Однако при работе с большими объёмами
данных следует быть осторожным: длительные транзакции могут блокировать таблицы и вызвать проблемы в продакшн-среде.

```typescript
await queryRunner.startTransaction();
try {
  await queryRunner.query(`UPDATE my_table SET column = new_value`);
  await queryRunner.commitTransaction();
} catch (error) {
  await queryRunner.rollbackTransaction();
}
```

#### 4. Фоновое выполнение миграций

Некоторые миграции можно выполнять асинхронно в фоне, особенно если они не критичны для работы основного приложения.
Это можно реализовать через отдельные сервисы или задачи (например, с использованием очередей).

### Как избежать простоя в продакшн-среде

В продакшн-среде любые изменения, приводящие к простоям, могут сильно повлиять на бизнес-процессы.
Вот несколько рекомендаций, как избежать простоев:

1. **Планирование миграций на внерабочее время** — запуск миграций в периоды низкой активности пользователей.
2. **Отделение чтения и записи** — настроить чтение данных с реплик базы данных, а не с основной, чтобы снизить нагрузку.
3. **Использование временных таблиц** — при создании больших объёмов данных можно сначала записать данные во
временные таблицы, а затем быстро перенести их в основную таблицу.

### Пример миграции с временными таблицами

Создание временной таблицы, заполнение её данными, а затем перенос данных в основную таблицу — это эффективный
способ минимизировать время блокировки основного ресурса.

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';

export class TemporaryTableMigration implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    // Создание временной таблицы
    await queryRunner.query(`CREATE TEMPORARY TABLE temp_table AS SELECT * FROM my_table`);

    // Обновление данных во временной таблице
    await queryRunner.query(`UPDATE temp_table SET column = new_value`);

    // Перенос данных обратно в основную таблицу
    await queryRunner.query(`INSERT INTO my_table SELECT * FROM temp_table ON CONFLICT DO UPDATE`);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // Логика отката
  }
}
```

### Уменьшение влияния миграций на производительность

Ниже приведены дополнительные советы по оптимизации миграций для крупных таблиц:

1. **Не блокирующие миграции** — по возможности избегайте `ALTER TABLE`, так как эта операция блокирует таблицу.
2. **Предварительная подготовка** — подготовка данных перед выполнением миграций позволяет ускорить процесс,
например, использование подготовленных запросов или индексирование.
3. **Разделение миграций** — если изменения сложные, разбейте миграцию на несколько этапов,
чтобы уменьшить нагрузку на базу данных.

### Заключение

Оптимизация миграций — это важный аспект, особенно в продакшн-среде, где сбои могут повлиять на пользователей.
В этой главе мы рассмотрели:

1. **Пакетную обработку данных** для снижения нагрузки.
2. **Создание и удаление индексов** для ускорения операций.
3. **Использование временных таблиц и транзакций** для надёжного выполнения миграций.
4. **Фоновое выполнение миграций** как способ избежать простоя.


## Глава 8: Создание и настройка Seed-данных для разработки и тестирования

Seed-данные — это предзаполненные данные, которые позволяют разработчикам и тестировщикам быстро создавать
начальное состояние базы данных для проведения тестов или настройки окружения разработки. Seed-данные могут
включать тестовые учётные записи, примеры товаров, категории и любую информацию, необходимую для запуска
приложения в локальной среде.

### Зачем нужны Seed-данные?

1. **Тестирование и разработка** — Seed-данные помогают разработчикам и тестировщикам быстрее приступить к работе,
избегая ручного заполнения базы.
2. **Проверка бизнес-логики** — Seed-данные позволяют проверять, как логика приложения работает с реальными примерами
данных.
3. **Автоматизация развёртывания** — при частых деплоях Seed-данные позволяют быстро разворачивать базу в нужном
состоянии.

### Структура Seed-данных

Seed-данные можно разделить на два типа:
- **Общие данные**: Стандартные данные, такие как категории, валюты, статусы заказов, которые остаются неизменными
для всех окружений.
- **Тестовые данные**: Профили пользователей, заказы, примеры продуктов — данные, которые можно изменять и удалять
в процессе тестирования.

### Подготовка Seed-данных в TypeORM

Для генерации Seed-данных в TypeORM можно использовать миграции или специальные скрипты, которые наполняют базу
данных начальной информацией. В TypeORM рекомендуется создавать отдельные миграции для Seed-данных,
чтобы их можно было легко запускать или откатывать.

#### Пример создания Seed-модуля для NestJS

1. Создадим специальный модуль `SeedModule` и сервис для управления Seed-данными.

2. Используем сервис для вставки данных в нужные таблицы базы.

##### Шаг 1. Создание Seed-сервиса

В `seed.service.ts` создадим логику для добавления начальных данных в базу.

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { Product } from './entities/product.entity';

@Injectable()
export class SeedService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(Product)
    private readonly productRepository: Repository<Product>,
  ) {}

  async seedUsers() {
    const users = [
      { username: 'testuser1', email: 'test1@example.com' },
      { username: 'testuser2', email: 'test2@example.com' },
    ];

    await this.userRepository.save(users);
  }

  async seedProducts() {
    const products = [
      { name: 'Product A', price: 100 },
      { name: 'Product B', price: 200 },
    ];

    await this.productRepository.save(products);
  }

  async runSeed() {
    await this.seedUsers();
    await this.seedProducts();
  }
}
```

Этот сервис включает методы `seedUsers` и `seedProducts` для добавления пользователей и продуктов в базу.

##### Шаг 2. Создание Seed-модуля

Создадим модуль `SeedModule`, который будет использовать `SeedService` для выполнения генерации данных.

```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { SeedService } from './seed.service';
import { User } from './entities/user.entity';
import { Product } from './entities/product.entity';

@Module({
  imports: [TypeOrmModule.forFeature([User, Product])],
  providers: [SeedService],
})
export class SeedModule {}
```

##### Шаг 3. Запуск Seed-скрипта

В `main.ts` добавим скрипт, который будет выполнять `runSeed()` при запуске приложения. Обратите внимание,
что запускать Seed-данные в продакшн-среде не рекомендуется.

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { SeedService } from './seed/seed.service';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  const seedService = app.get(SeedService);

  // Запускаем Seed-данные
  await seedService.runSeed();

  await app.listen(3000);
}
bootstrap();
```

### Разделение Seed-данных по окружениям

Иногда требуется, чтобы данные различались в зависимости от окружения (например, между продакшн и dev-окружением).
Это можно сделать, передавая параметры через переменные окружения.

#### Пример использования переменных окружения

```typescript
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  const seedService = app.get(SeedService);

  if (process.env.NODE_ENV === 'development') {
    await seedService.runSeed();
  }

  await app.listen(3000);
}
```

### Советы по организации Seed-данных

1. **Минимализм** — добавляйте только необходимые данные, чтобы не перегружать базу.
2. **Регулярное обновление** — Seed-данные должны отражать актуальную структуру базы.
3. **Управление зависимостями** — если данные зависят друг от друга (например, заказы зависят от пользователей),
убедитесь, что зависимости загружаются в правильном порядке.

### Пример удаления Seed-данных

Если Seed-данные больше не нужны, можно добавить метод для их удаления. Это полезно для тестовых окружений,
чтобы сбросить данные перед следующим тестом.

```typescript
async clearSeedData() {
  await this.productRepository.delete({});
  await this.userRepository.delete({});
}
```

### Заключение

Seed-данные значительно упрощают работу в локальной и тестовой средах, ускоряя настройку начального состояния
базы и предоставляя примеры данных для тестирования. В этой главе мы рассмотрели:

1. **Создание и настройку Seed-сервиса и Seed-модуля**.
2. **Разделение Seed-данных по окружениям** с использованием переменных.
3. **Практические советы по управлению Seed-данными**.

В следующей главе мы разберём процесс миграции данных между разными версиями базы данных и познакомимся с
подходами к изменению структуры данных при обновлении приложения.

---

## Глава 9: Миграции данных и управление версиями базы данных

Миграции данных играют ключевую роль в поддержании актуальности структуры базы данных, особенно в проектах с
активной разработкой. Они позволяют изменять структуру таблиц, добавлять новые поля, создавать индексы и управлять версиями базы без потери данных.

### Основы миграций

Миграции в TypeORM представляют собой версии изменений в базе, которые сохраняются в виде отдельных файлов.
Каждая миграция фиксирует изменения, такие как добавление новой колонки или изменение типа данных,
и позволяет откатиться к предыдущей версии базы при необходимости.

### Пример использования миграций в проекте с TypeORM

Чтобы создать и управлять миграциями в TypeORM, можно использовать встроенные команды CLI.
Эти команды создают файлы миграций, содержащие SQL-запросы для обновления или отката изменений в базе данных.

#### Настройка CLI для миграций

Для начала убедимся, что `TypeORM CLI` настроен на корректную работу с миграциями:

1. Добавьте в `package.json` команды для генерации и выполнения миграций:

```json
"scripts": {
  "typeorm": "typeorm-ts-node-commonjs",
  "migration:generate": "typeorm migration:generate -d src/migrations",
  "migration:run": "typeorm migration:run",
  "migration:revert": "typeorm migration:revert"
}
```

2. Проверьте конфигурацию TypeORM в `app.module.ts` или файле конфигурации:

```typescript
TypeOrmModule.forRoot({
  type: 'postgres',
  host: 'localhost',
  port: 5432,
  username: 'user',
  password: 'password',
  database: 'database',
  entities: [__dirname + '/**/*.entity{.ts,.js}'],
  migrations: [__dirname + '/migrations/*{.ts,.js}'],
  synchronize: false, // выключаем, чтобы использовать миграции
})
```

> ⚠️ **Важное замечание**: Параметр `synchronize` должен быть `false`, когда мы используем миграции,
чтобы предотвратить автоматическое изменение структуры таблиц.

### Создание новой миграции

Для создания миграции используем команду `migration:generate`. Эта команда автоматически генерирует файл
миграции на основе текущих изменений в сущностях.

```bash
npm run migration:generate -- -n AddNewColumnToUsers
```

Эта команда создаст миграцию, в которой TypeORM сравнит текущую структуру базы данных с новой структурой
в сущностях и внесёт все необходимые изменения.

#### Пример миграции

Предположим, мы добавляем новое поле `profileImage` в сущность `User`.
После внесения этого изменения в `user.entity.ts`, TypeORM CLI создаст следующую миграцию:

```typescript
import { MigrationInterface, QueryRunner, TableColumn } from "typeorm";

export class AddProfileImageToUser1658922010540 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.addColumn("user", new TableColumn({
      name: "profileImage",
      type: "varchar",
      isNullable: true,
    }));
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropColumn("user", "profileImage");
  }
}
```

Здесь метод `up` добавляет колонку, а метод `down` откатывает изменения, удаляя колонку.
Это позволяет откатить миграцию в случае необходимости.

### Выполнение и откат миграций

1. **Запуск миграций**. Чтобы применить миграции и обновить базу данных, используем команду:

   ```bash
   npm run migration:run
   ```

2. **Откат миграций**. Если миграция привела к ошибке или её нужно отменить, можно откатить последнюю миграцию командой:

   ```bash
   npm run migration:revert
   ```

### Рекомендации по работе с миграциями

1. **Минимизация изменений** — старайтесь вносить изменения в несколько миграций,
чтобы каждый файл содержал одно логическое изменение, например, добавление новой колонки или таблицы.

2. **Проверка данных** — перед выполнением миграций убедитесь, что данные, которые могут быть затронуты изменениями,
сохранены или защищены.

3. **Использование транзакций** — для комплексных изменений базы, состоящих из нескольких шагов,
используйте транзакции, чтобы все изменения были выполнены как единое целое.

4. **Создание резервных копий** — перед применением миграций на продакшн-среде обязательно создавайте
 бэкапы базы данных, чтобы избежать потери данных при ошибках.

### Пример использования транзакций в миграции

Если изменения зависят друг от друга, лучше объединить их в транзакцию. Например:

```typescript
public async up(queryRunner: QueryRunner): Promise<void> {
  await queryRunner.startTransaction();
  try {
    await queryRunner.addColumn("user", new TableColumn({
      name: "isVerified",
      type: "boolean",
      default: false,
    }));
    await queryRunner.addColumn("user", new TableColumn({
      name: "verificationCode",
      type: "varchar",
      isNullable: true,
    }));
    await queryRunner.commitTransaction();
  } catch (error) {
    await queryRunner.rollbackTransaction();
    throw error;
  }
}
```

Здесь, если ошибка возникнет при добавлении `verificationCode`, TypeORM откатит добавление `isVerified`,
обеспечивая целостность данных.

### Заключение

Миграции играют важную роль в поддержании структуры базы данных и управлении версиями данных.
В этой главе мы рассмотрели:

1. **Настройку и использование миграций в TypeORM**.
2. **Практические рекомендации** по созданию и управлению миграциями.
3. **Использование транзакций для сложных изменений**.


## Глава 10: ER-диаграммы и проектирование базы данных

Эффективное проектирование базы данных — ключ к успешной разработке проекта, особенно если проект предполагает
масштабируемость и высокую производительность. В этом разделе мы рассмотрим **ER-диаграммы** и их использование
для планирования структуры базы данных.

### Основы ER-диаграмм

**ER-диаграммы** (Entity-Relationship диаграммы) — это графические схемы, отображающие сущности и связи между ними.
Они используются на этапе проектирования базы данных, чтобы визуализировать и понять логические взаимосвязи в данных.

#### Основные компоненты ER-диаграмм

1. **Сущности (Entities)** — объекты, представляющие данные. Например, в системе управления пользователями
сущностями могут быть `User`, `Profile`, `Post`.

2. **Атрибуты (Attributes)** — характеристики, описывающие сущность. Например, у сущности `User` атрибутами
могут быть `name`, `email`, `password`.

3. **Связи (Relationships)** — связи между сущностями, представляющие отношения. Например, `User` может
быть связан с `Post` через связь "публикует", так как один пользователь может публиковать много постов.

### Типы связей

В ER-диаграммах принято выделять несколько типов связей между сущностями:

1. **Один к одному (One-to-One)** — когда одна запись в таблице может быть связана только с одной записью
в другой таблице. Например, `User` и `Profile` могут быть связаны один к одному, так как у каждого пользователя
есть только один профиль.

2. **Один ко многим (One-to-Many)** — когда одна запись в таблице может быть связана с несколькими записями
в другой таблице. Например, один `User` может иметь много `Post`, но каждый `Post` принадлежит только одному `User`.

3. **Многие ко многим (Many-to-Many)** — когда записи в одной таблице могут быть связаны с несколькими записями
в другой таблице и наоборот. Например, `User` и `Group` могут быть связаны "многие ко многим",
так как один пользователь может состоять в нескольких группах, и одна группа может включать нескольких пользователей.

### Реализация связей в TypeORM

TypeORM предоставляет инструменты для работы с реляционными связями, которые помогают легко настраивать
связи между сущностями.

#### Один к одному (One-to-One)

Рассмотрим пример связи "один к одному" между `User` и `Profile`.

```typescript
// user.entity.ts
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @OneToOne(() => Profile)
  @JoinColumn() // определяет внешний ключ для связи
  profile: Profile;
}
```

```typescript
// profile.entity.ts
@Entity()
export class Profile {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  bio: string;

  @OneToOne(() => User, (user) => user.profile)
  user: User;
}
```

В этом примере `JoinColumn` указывает на то, что `User` является владельцем связи и содержит внешний ключ для `Profile`.

#### Один ко многим (One-to-Many)

Теперь рассмотрим связь "один ко многим" между `User` и `Post`.

```typescript
// user.entity.ts
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @OneToMany(() => Post, (post) => post.user)
  posts: Post[];
}
```

```typescript
// post.entity.ts
@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @ManyToOne(() => User, (user) => user.posts)
  user: User;
}
```

Здесь `User` может иметь много `Post`, но каждый `Post` принадлежит только одному `User`.

#### Многие ко многим (Many-to-Many)

Для создания связи "многие ко многим" между `User` и `Group` требуется промежуточная таблица, которая будет
хранить связи между пользователями и группами.

```typescript
// user.entity.ts
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @ManyToMany(() => Group, (group) => group.users)
  @JoinTable() // создаем промежуточную таблицу
  groups: Group[];
}
```

```typescript
// group.entity.ts
@Entity()
export class Group {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @ManyToMany(() => User, (user) => user.groups)
  users: User[];
}
```

В данном случае TypeORM создаст промежуточную таблицу, которая будет хранить пары `user_id` и `group_id`.

### Создание ER-диаграммы для вашего проекта

На практике ER-диаграммы могут помочь лучше понять архитектуру базы данных, особенно на начальном этапе проектирования.
Вот пример простой ER-диаграммы для системы блогов:

```
+----------+      +---------+      +----------+
|   User   | ---- | Profile |      |   Post   |
+----------+      +---------+      +----------+
| id       |      | id      |      | id       |
| name     |      | bio     |      | title    |
| email    |      | user_id |      | content  |
+----------+      +---------+      | user_id  |
                                   +----------+
```

В этом примере `User` связан с `Profile` один к одному и с `Post` один ко многим.

### Заключение

ER-диаграммы и эффективное проектирование базы данных помогают создавать понятную и масштабируемую структуру
для хранения данных, что критически важно для полноценных проектов.

В этой главе мы:

1. Изучили компоненты ER-диаграмм и основные типы связей.
2. Рассмотрели, как реализовать связи в TypeORM с примерами.
3. Оценили значение ER-диаграмм на этапе проектирования базы данных.
