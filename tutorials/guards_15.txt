Доделаем прошлый урок:
Переделываем auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import * as bcrypt from 'bcrypt';

import { RefreshTokenRepository } from '../../repositories/services/refresh-token.repository';
import { UserRepository } from '../../repositories/services/user.repository';
import { UserMapper } from '../../users/services/user.mapper';
import { LoginReqDto } from '../models/dto/req/login.req.dto';
import { RegistrationReqDto } from '../models/dto/req/registration.req.dto';
import { AuthResDto } from '../models/dto/res/auth.res.dto';
import { AuthCacheService } from './auth-cache-service';
import { TokenService } from './token.service';

@Injectable()
export class AuthService {
  constructor(
    private readonly authCacheService: AuthCacheService,
    private readonly tokenService: TokenService,
    private readonly userRepository: UserRepository,
    private readonly refreshTokenRepository: RefreshTokenRepository,
  ) {}

  public async registration(dto: RegistrationReqDto): Promise<AuthResDto> {
    await this.isEmailNotExistOrThrow(dto.email);
    const password = await bcrypt.hash(dto.password, 10);
    const user = await this.userRepository.save(
      this.userRepository.create({ ...dto, password }),
    );
    const tokens = await this.tokenService.generateAuthTokens({
      userId: user.id,
      deviceId: dto.deviceId,
    });
    await Promise.all([
      this.authCacheService.saveToken(
        tokens.accessToken,
        user.id,
        dto.deviceId,
      ),
      this.refreshTokenRepository.save(
        this.refreshTokenRepository.create({
          user_id: user.id,
          deviceId: dto.deviceId,
          refreshToken: tokens.refreshToken,
        }),
      ),
    ]);

    return { user: UserMapper.toResDto(user), tokens };
  }

  public async login(dto: LoginReqDto): Promise<any> {
    const user = await this.userRepository.findOne({
      where: { email: dto.email },
      select: ['id', 'password'],
    });
    if (!user) {
      throw new UnauthorizedException();
    }
    const isPasswordValid = await bcrypt.compare(dto.password, user.password);
    if (!isPasswordValid) {
      throw new UnauthorizedException();
    }

    const tokens = await this.tokenService.generateAuthTokens({
      userId: user.id,
      deviceId: dto.deviceId,
    });
    await Promise.all([
      this.authCacheService.saveToken(
        tokens.accessToken,
        user.id,
        dto.deviceId,
      ),
      this.refreshTokenRepository.save(
        this.refreshTokenRepository.create({
          user_id: user.id,
          deviceId: dto.deviceId,
          refreshToken: tokens.refreshToken,
        }),
      ),
    ]);
    const userEntity = await this.userRepository.findOneBy({ id: user.id });

    return { user: UserMapper.toResDto(userEntity), tokens };
  }

  private async isEmailNotExistOrThrow(email: string) {
    const user = await this.userRepository.findOneBy({ email });
    if (user) {
      throw new Error('Email already exists');
    }
  }
}

Исправляем ошибки в article.service.ts
import { Injectable } from '@nestjs/common';

import { CommentsService } from '../../comments/services/comments.service';
import { UsersService } from '../../users/services/users.service';
import { CreateArticleDto } from '../models/dto/req/create-article.dto';
import { UpdateArticleDto } from '../models/dto/req/update-article.dto';

@Injectable()
export class ArticlesService {
  constructor(
    private readonly userService: UsersService,
    private readonly commentsService: CommentsService,
  ) {}

  create(dto: CreateArticleDto) {
    return 'This action adds a new user';
  }

  findAll() {
    return `This action returns all users`;
  }

  findOne(id: number) {
    return `This action returns a #${id} user`;
  }

  update(id: number, updateUserDto: UpdateArticleDto) {
    return `This action updates a #${id} user`;
  }

  remove(id: number) {
    this.commentsService.deleteAllCommentsForArticle('articleId');
    return `This action removes a #${id} user`;
  }
}

Исправляем user.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

import { ArticleID, UserID } from '../../../common/types/entity-ids.type';
import { ConfigType } from '../../../configs/config.type';
import { ArticleRepository } from '../../repositories/services/article.repository';
import { UserRepository } from '../../repositories/services/user.repository';
import { UpdateUserReqDto } from '../models/dto/req/update-user.req.dto';

@Injectable()
export class UsersService {
  constructor(
    private readonly configService: ConfigService<ConfigType>,
    private userRepository: UserRepository,
    private articleRepository: ArticleRepository,
  ) {}

  findOne(userId: UserID) {
    return `This action returns a #${userId} user`;
  }

  update(userId: UserID, updateUserDto: UpdateUserReqDto) {
    return `This action updates a #${userId} user`;
  }

  remove(userId: UserID) {
    return `This action removes a #${userId} user`;
  }

  public async checkAbilityToEditArticle(userId: UserID, articleId: ArticleID) {
    // Check if the user has permission to edit the article
    const article = await this.articleRepository.findOne({
      where: { id: articleId, user_id: userId },
    });
  }
}

Исправляем users.controller.ts
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  ParseUUIDPipe,
  Patch,
} from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';

import { UserID } from '../../common/types/entity-ids.type';
import { UpdateUserReqDto } from './models/dto/req/update-user.req.dto';
import { UsersService } from './services/users.service';

@ApiTags('Users')
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get(':userId')
  findOne(@Param('userId', ParseUUIDPipe) userId: UserID) {
    return this.usersService.findOne(userId);
  }

  @Patch(':userId')
  update(@Param('userId') userId: UserID, @Body() updateUserDto: UpdateUserReqDto) {
    return this.usersService.update(userId, updateUserDto);
  }

  @Delete(':userId')
  remove(@Param('userId') userId: UserID) {
    return this.usersService.remove(userId);
  }
}

Запускаем скрипты start:docker:local и start:dev и проверяем в swagger запуск auth/login
-------
Переходим к guards.
Для начала создадим новую папку src/modules/auth/guards В ней создадим файл jwt-access.guard.ts
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';

import { UserRepository } from '../../repositories/services/user.repository';
import { UserMapper } from '../../users/services/user.mapper';
// import { SKIP_AUTH } from '../decorators/skip-auth.decorator';
import { TokenType } from '../models/enums/token-type.enum';
import { AuthCacheService } from '../services/auth-cache-service';
import { TokenService } from '../services/token.service';

@Injectable()
export class JwtAccessGuard implements CanActivate {
  constructor(
    private readonly reflector: Reflector,
    private readonly tokenService: TokenService,
    private readonly authCacheService: AuthCacheService,
    private readonly userRepository: UserRepository,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    // const skipAuth = this.reflector.getAllAndOverride<boolean>(SKIP_AUTH, [
    //   context.getHandler(),
    //   context.getClass(),
    // ]);
    // if (skipAuth) return true;

    const request = context.switchToHttp().getRequest();
    const accessToken = request.get('Authorization')?.split('Bearer ')[1];
    if (!accessToken) {
      throw new UnauthorizedException();
    }
    const payload = await this.tokenService.verifyToken(
      accessToken,
      TokenType.ACCESS,
    );
    if (!payload) {
      throw new UnauthorizedException();
    }
    const isAccessTokenExist = await this.authCacheService.isAccessTokenExist(
      payload.userId,
      payload.deviceId,
      accessToken,
    );
    if (!isAccessTokenExist) {
      throw new UnauthorizedException();
    }
    const user = await this.userRepository.findOneBy({
      id: payload.userId,
    });
    if (!user) {
      throw new UnauthorizedException();
    }
    request.res.locals.user = UserMapper.toIUserData(user, payload);
    return true;
  }
}

Обновляем token.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config/dist/config.service';
import { JwtService } from '@nestjs/jwt';

import { ConfigType, JwtConfig } from '../../../configs/config.type';
import { TokenType } from '../models/enums/token-type.enum';
import { IJwtPayload } from '../models/interfaces/jwt-payload.interface';
import { ITokenPair } from '../models/interfaces/token-pair.interface';

@Injectable()
export class TokenService {
  private readonly jwtConfig: JwtConfig;

  constructor(
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService<ConfigType>,
  ) {
    this.jwtConfig = configService.get<JwtConfig>('jwt');
  }

  public async generateAuthTokens(payload: IJwtPayload): Promise<ITokenPair> {
    const accessToken = await this.jwtService.signAsync(payload, {
      secret: this.jwtConfig.accessSecret,
      expiresIn: this.jwtConfig.accessExpiresIn,
    });
    const refreshToken = await this.jwtService.signAsync(payload, {
      secret: this.jwtConfig.refreshSecret,
      expiresIn: this.jwtConfig.refreshExpiresIn,
    });
    return { accessToken, refreshToken };
  }

  public async verifyToken(
    token: string,
    type: TokenType,
  ): Promise<IJwtPayload> {
    try {
      return await this.jwtService.verifyAsync(token, {
        secret: this.getSecret(type),
      });
    } catch (e) {
      throw new UnauthorizedException('Invalid token');
    }
  }

  private getSecret(type: TokenType): string {
    let secret: string;
    switch (type) {
      case TokenType.ACCESS:
        secret = this.jwtConfig.accessSecret;
        break;
      case TokenType.REFRESH:
        secret = this.jwtConfig.refreshSecret;
        break;
      default:
        throw new Error('Unknown token type');
    }
    return secret;
  }
}

Далее чтобы все работало нам надо добавить папку src/modules/auth/models/enums а в ней файл token-type.enum.ts
export enum TokenType {
  ACCESS = 'access',
  REFRESH = 'refresh',
}

Обновляем auth-cache-service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config/dist/config.service';

import { ConfigType, JwtConfig } from '../../../configs/config.type';
import { RedisService } from '../../redis/services/redis.service';

@Injectable()
export class AuthCacheService {
  private jwtConfig: JwtConfig;

  constructor(
    private readonly redisService: RedisService,
    private readonly configService: ConfigService<ConfigType>,
  ) {
    this.jwtConfig = this.configService.get('jwt');
  }

  public async saveToken(
    token: string,
    userId: string,
    deviceId: string,
  ): Promise<void> {
    const key = this.getKey(userId, deviceId);

    await this.redisService.deleteByKey(key);
    await this.redisService.addOneToSet(key, token);
    await this.redisService.expire(key, this.jwtConfig.accessExpiresIn);
  }

  public async isAccessTokenExist(
    userId: string,
    deviceId: string,
    token: string,
  ): Promise<boolean> {
    const key = this.getKey(userId, deviceId);

    const set = await this.redisService.sMembers(key);
    return set.includes(token);
  }

  public async deleteToken(userId: string, deviceId: string): Promise<void> {
    const key = this.getKey(userId, deviceId);
    await this.redisService.deleteByKey(key);
  }

  private getKey(userId: string, deviceId: string): string {
    return `ACCESS_TOKEN:${userId}:${deviceId}`;
  }
}

Обновляем jwt-payload.interface.ts
import { UserID } from '../../../../common/types/entity-ids.type';

export interface IJwtPayload {
  deviceId: string;
  userId: UserID;
}

Обновляем user.mapper.ts
import { UserEntity } from '../../../database/entities/user.entity';
import { IJwtPayload } from '../../auth/models/interfaces/jwt-payload.interface';
import { UserResDto } from '../models/dto/res/user.res.dto';

export class UserMapper {
  public static toResDto(user: UserEntity): UserResDto {
    return {
      id: user.id,
      name: user.name,
      email: user.email,
      bio: user.bio,
      image: user.image,
    };
  }

  public static toIUserData(user: UserEntity, jwtPayload: IJwtPayload): any {
    return {
      userId: user.id,
      deviceId: jwtPayload.deviceId,
      email: user.email,
    };
  }
}

Для проверки логирования в файл user.controller.ts добавим
@ApiBearerAuth()
 @Get('me')
  public async findMe() {
    return await this.usersService.findMe();
  }
а в файл user.service.ts добавим
findMe() {
    return `This action returns a #${123} user`;
  }

Теперь идем в swagger в раздел auth/login нажимаем на try it out потом на execute далее ниже копируем accessToken.
Идем в самый верх и нажимаем на Authorize и вставляем скопированный accessToken Далее смотрим на раздел users/me на
нем теперь висит замочек который, указывает на то что нам надо сделать авторизацию, но её сейчас нет
В смысле сам swagger нас сейчас немного обманывает потому что если мы сделаем запрос то он отработает успешно,
но не проверяет наши токены которые мы сюда положили. Замочек дает возможность со swagger просто отправить наш токен.
Для того чтобы его проверить нам надо использовать тот guards что мы написали, потому что она существует в
отдельном файле, но нигде не подключена. Для этого в файле users.controller.ts к методу findMe надо добавить
декоратор @UseGuard() а в нем указать на наш файл JwtAccessGuard в итоге выйдет это:
@UseGuards(JwtAccessGuard)
  @ApiBearerAuth()
  @Get('me')
  public async findMe() {
    return await this.usersService.findMe();
  }

Но сейчас будет выдавать ошибку так как JwtAccessGuard не является частью модуля user
Для этого идем в auth.module.ts и делаем JwtAccessGuard частью провайдера а так же експортироваться из
него вместе с TokenService и AuthCacheService
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';

import { RedisModule } from '../redis/redis.module';
import { AuthController } from './auth.controller';
import { JwtAccessGuard } from './guards/jwt-access.guard';
import { AuthService } from './services/auth.service';
import { AuthCacheService } from './services/auth-cache-service';
import { TokenService } from './services/token.service';

@Module({
  imports: [JwtModule, RedisModule],
  controllers: [AuthController],
  providers: [AuthService, AuthCacheService, TokenService, JwtAccessGuard],
  exports: [JwtAccessGuard, TokenService, AuthCacheService],
})
export class AuthModule {}


Теперь идем в users.module.ts и в импорт добовляем AuthModule
import { forwardRef, Module } from '@nestjs/common';

import { ArticlesModule } from '../articles/articles.module';
import { AuthModule } from '../auth/auth.module';
import { UsersService } from './services/users.service';
import { UsersAdminService } from './services/users-admin.service';
import { UsersController } from './users.controller';
import { UsersAdminController } from './users-admin.controller';

@Module({
  imports: [forwardRef(() => ArticlesModule), AuthModule],
  controllers: [UsersController, UsersAdminController],
  providers: [UsersService, UsersAdminService],
  exports: [UsersService],
})
export class UsersModule {}

Теперь проблема в том что везде где нам надо будет проверять нашу авторизацию нам нужно будет везде
импортировать наш auth.module.ts и использовать все то что он експортирует.
Чтобы этого избежать есть метод, который позволяет использовать guard глобально.
Для этого идем в наш файл auth.module.ts и добовляем подключение в провайдере, а JwtAccessGuard убираем.
Так же теперь ненадо ничего експортировать.
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { JwtModule } from '@nestjs/jwt';

import { RedisModule } from '../redis/redis.module';
import { AuthController } from './auth.controller';
import { JwtAccessGuard } from './guards/jwt-access.guard';
import { AuthService } from './services/auth.service';
import { AuthCacheService } from './services/auth-cache-service';
import { TokenService } from './services/token.service';

@Module({
  imports: [JwtModule, RedisModule],
  controllers: [AuthController],
  providers: [
    {
      provide: APP_GUARD,
      useClass: JwtAccessGuard,
    },
    AuthService,
    AuthCacheService,
    TokenService,
  ],
  exports: [],
})
export class AuthModule {}

Файл users-admin.service.ts и users-dmin.controller.ts удоляем. А в файле users.controller.ts теперь
убираем декоратор @UseGuard() потому что он теперь глобальный и будет использован для всех ендпоинтов во всех контролерах.
Это всё что надо было сделать. Весь модуль не надо делать глобальным, а только саму guard.
Теперь его можно использовать из любого места.
Но есть ньюанс. Теперь все ендпоинты в swagger будут требовать авторизацию, но нам это не надо.
Чтобы этого избежать мы будем использовать декоратор в каждом ендпоинте где надо пропустить проверку нашего guard.
Вот ссылка на документацию https://docs.nestjs.com/recipes/passport
Для этого создадим папку src/modules/auth/decorators  а внем файл skip-auth.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const SKIP_AUTH = 'SKIP_AUTH';
export const SkipAuth = () => SetMetadata(SKIP_AUTH, true);

Теперь в нашем файле jwt-access.guard.ts надо раскоментировать часть нашего кода
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';

import { UserRepository } from '../../repositories/services/user.repository';
import { UserMapper } from '../../users/services/user.mapper';
import { SKIP_AUTH } from '../decorators/skip-auth.decorator';
import { TokenType } from '../models/enums/token-type.enum';
import { AuthCacheService } from '../services/auth-cache-service';
import { TokenService } from '../services/token.service';

@Injectable()
export class JwtAccessGuard implements CanActivate {
  constructor(
    private readonly reflector: Reflector,
    private readonly tokenService: TokenService,
    private readonly authCacheService: AuthCacheService,
    private readonly userRepository: UserRepository,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const skipAuth = this.reflector.getAllAndOverride<boolean>(SKIP_AUTH, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (skipAuth) return true;

    const request = context.switchToHttp().getRequest();
    const accessToken = request.get('Authorization')?.split('Bearer ')[1];
    if (!accessToken) {
      throw new UnauthorizedException();
    }
    const payload = await this.tokenService.verifyToken(
      accessToken,
      TokenType.ACCESS,
    );
    if (!payload) {
      throw new UnauthorizedException();
    }
    const isAccessTokenExist = await this.authCacheService.isAccessTokenExist(
      payload.userId,
      payload.deviceId,
      accessToken,
    );
    if (!isAccessTokenExist) {
      throw new UnauthorizedException();
    }
    const user = await this.userRepository.findOneBy({
      id: payload.userId,
    });
    if (!user) {
      throw new UnauthorizedException();
    }
    request.res.locals.user = UserMapper.toIUserData(user, payload);
    return true;
  }
}

Теперь в нашем файле auth.controller.ts мы можем применить декоратор @SkipAuth()
import { Body, Controller, Post } from '@nestjs/common';
import { ApiTags } from '@nestjs/swagger';

import { SkipAuth } from './decorators/skip-auth.decorator';
import { LoginReqDto } from './models/dto/req/login.req.dto';
import { RegistrationReqDto } from './models/dto/req/registration.req.dto';
import { AuthResDto } from './models/dto/res/auth.res.dto';
import { AuthService } from './services/auth.service';

@ApiTags('Auth')
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @SkipAuth()
  @Post('register')
  public async registration(
    @Body() dto: RegistrationReqDto,
  ): Promise<AuthResDto> {
    return await this.authService.registration(dto);
  }

  @SkipAuth()
  @Post('login')
  public async login(@Body() dto: LoginReqDto): Promise<AuthResDto> {
    return await this.authService.login(dto);
  }
}

Что он делает? Когда мы приходим на register или login то у нас добавляются какието методанные.
Если мы посмотрим на наш файл skip-auth.decorator.ts то увидим что он единственное что делает так это добовляет
до наших методанных SetMetadata - специальный метод который мы можем добавить к нашему методу.
Мы можем положить туда что угодно что в будущем нам сможет помочь модифицировать логику поведения нашего ендпоинта.
Там где у нас стоит декоратор @ApiBearerAuth() там не надо ставить @SkipAuth() чтобы наш guard работал успешно
Теперь обновим наш users.controller.ts ВАЖНО: Порядок ендпоинтов имеет значение по этому динамический путь
надо класть ниже.
Обновляем наш users.controller.ts
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  ParseUUIDPipe,
  Patch,
} from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';

import { UserID } from '../../common/types/entity-ids.type';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { IUserData } from '../auth/models/interfaces/user-data.interface';
import { UpdateUserReqDto } from './models/dto/req/update-user.req.dto';
import { UsersService } from './services/users.service';

@ApiTags('Users')
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @ApiBearerAuth()
  @Get('me')
  public async findMe(@CurrentUser() userData: IUserData) {
    return await this.usersService.findMe(userData);
  }

  @ApiBearerAuth()
  @Patch('me')
  public async updateMe(
    @CurrentUser() userData: IUserData,
    @Body() updateUserDto: UpdateUserReqDto,
  ) {
    return await this.usersService.updateMe(userData, updateUserDto);
  }

  @ApiBearerAuth()
  @Delete('me')
  public async removeMe(@CurrentUser() userData: IUserData) {
    return await this.usersService.removeMe(userData);
  }

  @Get(':userId')
  public async findOne(@Param('userId', ParseUUIDPipe) userId: UserID) {
    return await this.usersService.findOne(userId);
  }
}

Обновляем наш users.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

import { UserID } from '../../../common/types/entity-ids.type';
import { ConfigType } from '../../../configs/config.type';
import { IUserData } from '../../auth/models/interfaces/user-data.interface';
import { ArticleRepository } from '../../repositories/services/article.repository';
import { UserRepository } from '../../repositories/services/user.repository';
import { UpdateUserReqDto } from '../models/dto/req/update-user.req.dto';

@Injectable()
export class UsersService {
  constructor(
    private readonly configService: ConfigService<ConfigType>,
    private userRepository: UserRepository,
    private articleRepository: ArticleRepository,
  ) {}

  public async findMe(userData: IUserData) {
    return `This action returns a #${userData.userId} user`;
  }

  public async updateMe(userData: IUserData, dto: UpdateUserReqDto) {
    return `This action updates a #${userData.userId} user`;
  }

  public async removeMe(userData: IUserData) {
    return `This action removes a #${userData.userId} user`;
  }

  public async findOne(userId: UserID) {
    return `This action returns a #${userId} user`;
  }
}

Писать public не обязательно ьак как это дефолтное состояние.
Для того чтобы это заработало мы напишем декоратор, который поможет нам доставать наши переменные userData.
Для этого тдем в папку src/modules/auth/decorators и создадим файл current-user.decorator.ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator(
  (data: unknown, context: ExecutionContext) => {
    const request = context.switchToHttp().getRequest();
    return request.res.locals.user;
  },
);

И в папке src/modules/auth/models/interfaces создадим файл user-data.interface.ts
import { UserID } from '../../../../common/types/entity-ids.type';

export interface IUserData {
  userId: UserID;
  deviceId: string;
  email: string;
}

И теперь везде на всех закрытых ендпоинтах у нас есть возможность написать доступ к нашим данным человека который
пришел к нам с токеном.
Проверяем в swagger на ендпоинтах GET users/me и PATCH users/me и видим что данные проходят и все работает.
Мы просто подготовили авторизацию под то чтобы позднее использовать данные авторизованного юзера.

Теперь делаем guard для нашего refreshToken
В папке src/modules/auth/guards добовляем файл jwt-refresh.guard.ts
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';

import { RefreshTokenRepository } from '../../repositories/services/refresh-token.repository';
import { UserRepository } from '../../repositories/services/user.repository';
import { UserMapper } from '../../users/services/user.mapper';
import { TokenType } from '../models/enums/token-type.enum';
import { TokenService } from '../services/token.service';

@Injectable()
export class JwtRefreshGuard implements CanActivate {
  constructor(
    private readonly reflector: Reflector,
    private readonly tokenService: TokenService,
    private readonly refreshTokenRepository: RefreshTokenRepository,
    private readonly userRepository: UserRepository,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const refreshToken = request.get('Authorization')?.split('Bearer ')[1];
    if (!refreshToken) {
      throw new UnauthorizedException();
    }

    const payload = await this.tokenService.verifyToken(
      refreshToken,
      TokenType.REFRESH,
    );
    if (!payload) {
      throw new UnauthorizedException();
    }

    const isRefreshTokenExist =
      await this.refreshTokenRepository.isRefreshTokenExist(refreshToken);
    if (!isRefreshTokenExist) {
      throw new UnauthorizedException();
    }

    const user = await this.userRepository.findOneBy({
      id: payload.userId,
    });
    if (!user) {
      throw new UnauthorizedException();
    }

    request.res.locals.user = UserMapper.toIUserData(user, payload);
    return true;
  }
}

Обновляем наш auth.controller.ts
import { Body, Controller, Post, UseGuards } from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';

import { CurrentUser } from './decorators/current-user.decorator';
import { SkipAuth } from './decorators/skip-auth.decorator';
import { JwtRefreshGuard } from './guards/jwt-refresh.guard';
import { LoginReqDto } from './models/dto/req/login.req.dto';
import { RegistrationReqDto } from './models/dto/req/registration.req.dto';
import { AuthResDto } from './models/dto/res/auth.res.dto';
import { TokenPairResDto } from './models/dto/res/token-pair.res.dto';
import { IUserData } from './models/interfaces/user-data.interface';
import { AuthService } from './services/auth.service';

@ApiTags('Auth')
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @SkipAuth()
  @Post('sign-up')
  public async registration(
    @Body() dto: RegistrationReqDto,
  ): Promise<AuthResDto> {
    return await this.authService.registration(dto);
  }

  @SkipAuth()
  @Post('sign-in')
  public async login(@Body() dto: LoginReqDto): Promise<AuthResDto> {
    return await this.authService.login(dto);
  }

  @ApiBearerAuth()
  @Post('sign-out')
  public async logOut(@CurrentUser() userData: IUserData): Promise<void> {
    return await this.authService.logOut(userData);
  }

  @SkipAuth()
  @ApiBearerAuth()
  @UseGuards(JwtRefreshGuard)
  @Post('refresh')
  public async refresh(
    @CurrentUser() userData: IUserData,
  ): Promise<TokenPairResDto> {
    return await this.authService.refresh(userData);
  }
}

Теперь нам нужен метод для того чтобы проверить токен всередине нашей базы данных.
Для этого обновим наш файл refresh-token.repository.ts в папке src/modules/repositories/services
import { Injectable } from '@nestjs/common';
import { DataSource, Repository } from 'typeorm';

import { RefreshTokenEntity } from '../../../database/entities/refresh-token.entity';

@Injectable()
export class RefreshTokenRepository extends Repository<RefreshTokenEntity> {
  constructor(private readonly dataSource: DataSource) {
    super(RefreshTokenEntity, dataSource.manager);
  }

  public async isRefreshTokenExist(refreshToken: string): Promise<boolean> {
    return await this.existsBy({ refreshToken });
  }
}

Обновляем наш auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import * as bcrypt from 'bcrypt';

import { RefreshTokenRepository } from '../../repositories/services/refresh-token.repository';
import { UserRepository } from '../../repositories/services/user.repository';
import { UserMapper } from '../../users/services/user.mapper';
import { LoginReqDto } from '../models/dto/req/login.req.dto';
import { RegistrationReqDto } from '../models/dto/req/registration.req.dto';
import { AuthResDto } from '../models/dto/res/auth.res.dto';
import { TokenPairResDto } from '../models/dto/res/token-pair.res.dto';
import { IUserData } from '../models/interfaces/user-data.interface';
import { AuthCacheService } from './auth-cache-service';
import { TokenService } from './token.service';

@Injectable()
export class AuthService {
  constructor(
    private readonly authCacheService: AuthCacheService,
    private readonly tokenService: TokenService,
    private readonly userRepository: UserRepository,
    private readonly refreshTokenRepository: RefreshTokenRepository,
  ) {}

  public async registration(dto: RegistrationReqDto): Promise<AuthResDto> {
    await this.isEmailNotExistOrThrow(dto.email);
    const password = await bcrypt.hash(dto.password, 10);
    const user = await this.userRepository.save(
      this.userRepository.create({ ...dto, password }),
    );
    const tokens = await this.tokenService.generateAuthTokens({
      userId: user.id,
      deviceId: dto.deviceId,
    });
    await Promise.all([
      this.authCacheService.saveToken(
        tokens.accessToken,
        user.id,
        dto.deviceId,
      ),
      this.refreshTokenRepository.save(
        this.refreshTokenRepository.create({
          user_id: user.id,
          deviceId: dto.deviceId,
          refreshToken: tokens.refreshToken,
        }),
      ),
    ]);

    return { user: UserMapper.toResDto(user), tokens };
  }

  public async login(dto: LoginReqDto): Promise<AuthResDto> {
    const user = await this.userRepository.findOne({
      where: { email: dto.email },
      select: ['id', 'password'],
    });
    if (!user) {
      throw new UnauthorizedException();
    }
    const isPasswordValid = await bcrypt.compare(dto.password, user.password);
    if (!isPasswordValid) {
      throw new UnauthorizedException();
    }

    const tokens = await this.tokenService.generateAuthTokens({
      userId: user.id,
      deviceId: dto.deviceId,
    });
    await Promise.all([
      this.authCacheService.saveToken(
        tokens.accessToken,
        user.id,
        dto.deviceId,
      ),
      this.refreshTokenRepository.save(
        this.refreshTokenRepository.create({
          user_id: user.id,
          deviceId: dto.deviceId,
          refreshToken: tokens.refreshToken,
        }),
      ),
    ]);
    const userEntity = await this.userRepository.findOneBy({ id: user.id });

    return { user: UserMapper.toResDto(userEntity), tokens };
  }

  public async logOut(userData: IUserData): Promise<void> {
    await Promise.all([
      this.authCacheService.deleteToken(userData.userId, userData.deviceId),
      this.refreshTokenRepository.delete({
        user_id: userData.userId,
        deviceId: userData.deviceId,
      }),
    ]);
  }

  public async refresh(userData: IUserData): Promise<TokenPairResDto> {
    await Promise.all([
      this.authCacheService.deleteToken(userData.userId, userData.deviceId),
      this.refreshTokenRepository.delete({
        user_id: userData.userId,
        deviceId: userData.deviceId,
      }),
    ]);

    const tokens = await this.tokenService.generateAuthTokens({
      userId: userData.userId,
      deviceId: userData.deviceId,
    });
    await Promise.all([
      this.authCacheService.saveToken(
        tokens.accessToken,
        userData.userId,
        userData.deviceId,
      ),
      this.refreshTokenRepository.save(
        this.refreshTokenRepository.create({
          user_id: userData.userId,
          deviceId: userData.deviceId,
          refreshToken: tokens.refreshToken,
        }),
      ),
    ]);

    return tokens;
  }

  private async isEmailNotExistOrThrow(email: string) {
    const user = await this.userRepository.findOneBy({ email });
    if (user) {
      throw new Error('Email already exists');
    }
  }
}

Файл JwtRefreshGuard подключаем в auth.module.ts в провайдеры
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { JwtModule } from '@nestjs/jwt';

import { RedisModule } from '../redis/redis.module';
import { AuthController } from './auth.controller';
import { JwtAccessGuard } from './guards/jwt-access.guard';
import { AuthService } from './services/auth.service';
import { AuthCacheService } from './services/auth-cache-service';
import { TokenService } from './services/token.service';
import { JwtRefreshGuard } from './guards/jwt-refresh.guard';

@Module({
  imports: [JwtModule, RedisModule],
  controllers: [AuthController],
  providers: [
    {
      provide: APP_GUARD,
      useClass: JwtAccessGuard,
    },
    JwtRefreshGuard,
    AuthService,
    AuthCacheService,
    TokenService,
  ],
  exports: [],
})
export class AuthModule {}

А в файл refresh-token.entity.ts добавим onDelete: 'CASCADE', для того чтобы при удалении юзера были удалены
все токены которые принадлежали ему.
import {
  Column,
  Entity,
  JoinColumn,
  ManyToOne,
  PrimaryGeneratedColumn,
} from 'typeorm';

import { RefreshTokenID, UserID } from '../../common/types/entity-ids.type';
import { TableNameEnum } from './enums/table-name.enum';
import { CreateUpdateModel } from './models/create-update.model';
import { UserEntity } from './user.entity';

@Entity(TableNameEnum.REFRESH_TOKENS)
export class RefreshTokenEntity extends CreateUpdateModel {
  @PrimaryGeneratedColumn('uuid')
  id: RefreshTokenID;

  @Column('text')
  refreshToken: string;

  @Column('text')
  deviceId: string;

  @Column()
  user_id: UserID;
  @ManyToOne(() => UserEntity, (entity) => entity.refreshTokens, {
    onDelete: 'CASCADE',
  })
  @JoinColumn({ name: 'user_id' })
  user?: UserEntity;
}

Каждый раз когда мы меняем наши таблици мы должны генерировать новые миграции. Например:
npm run migration:generate -name=fix-refresh-cascade

Обновим users.controller.ts
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  ParseUUIDPipe,
  Patch,
} from '@nestjs/common';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';

import { UserID } from '../../common/types/entity-ids.type';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { IUserData } from '../auth/models/interfaces/user-data.interface';
import { UpdateUserReqDto } from './models/dto/req/update-user.req.dto';
import { UserBaseResDto } from './models/dto/res/user-base.res.dto';
import { UserMapper } from './services/user.mapper';
import { UsersService } from './services/users.service';

@ApiTags('Users')
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @ApiBearerAuth()
  @Get('me')
  public async findMe(@CurrentUser() userData: IUserData) {
    return await this.usersService.findMe(userData);
  }

  @ApiBearerAuth()
  @Patch('me')
  public async updateMe(
    @CurrentUser() userData: IUserData,
    @Body() updateUserDto: UpdateUserReqDto,
  ) {
    return await this.usersService.updateMe(userData, updateUserDto);
  }

  @ApiBearerAuth()
  @Delete('me')
  public async removeMe(@CurrentUser() userData: IUserData) {
    return await this.usersService.removeMe(userData);
  }

  @Get(':userId')
  public async findOne(
    @Param('userId', ParseUUIDPipe) userId: UserID,
  ): Promise<UserBaseResDto> {
    const result = await this.usersService.findOne(userId);
    return UserMapper.toResDto(result);
  }
}

И файл users.service.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

import { UserID } from '../../../common/types/entity-ids.type';
import { ConfigType } from '../../../configs/config.type';
import { UserEntity } from '../../../database/entities/user.entity';
import { IUserData } from '../../auth/models/interfaces/user-data.interface';
import { ArticleRepository } from '../../repositories/services/article.repository';
import { UserRepository } from '../../repositories/services/user.repository';
import { UpdateUserReqDto } from '../models/dto/req/update-user.req.dto';

@Injectable()
export class UsersService {
  constructor(
    private readonly configService: ConfigService<ConfigType>,
    private userRepository: UserRepository,
    private articleRepository: ArticleRepository,
  ) {}

  public async findMe(userData: IUserData) {
    return `This action returns a #${userData.userId} user`;
  }

  public async updateMe(userData: IUserData, dto: UpdateUserReqDto) {
    return `This action updates a #${userData.userId} user`;
  }

  public async removeMe(userData: IUserData) {
    return `This action removes a #${userData.userId} user`;
  }

  public async findOne(userId: UserID): Promise<UserEntity> {
    return await this.userRepository.findOneBy({ id: userId });
  }
}



ДОКУМЕНТАЦИЯ:
Guards
Guard — это класс, аннотированный декоратором @Injectable(), который реализует интерфейс CanActivate.

У Guards есть одна обязанность. Они определяют, будет ли данный запрос обработан обработчиком маршрута или нет,
в зависимости от определенных условий (таких, как разрешения, роли, списки контроля доступа и т. д.), присутствующих
во время выполнения. Это часто называют авторизацией. Авторизация (и ее двоюродный брат, аутентификация,
с которой она обычно сотрудничает) обычно обрабатывались промежуточным программным обеспечением в традиционных
приложениях Express. Промежуточное программное обеспечение является прекрасным выбором для аутентификации,
поскольку такие вещи, как проверка токена и присоединение свойств к объекту запроса, не сильно связаны с
конкретным контекстом маршрута (и его метаданными).

Но промежуточное программное обеспечение по своей природе глупое. Оно не знает, какой обработчик будет
выполнен после вызова функции next(). С другой стороны, Guards имеют доступ к экземпляру ExecutionContext и,
таким образом, точно знают, что будет выполнено дальше. Они разработаны, как и фильтры исключений,
каналы и перехватчики, чтобы позволить вам вставлять логику обработки точно в нужную точку цикла запроса/ответа и
делать это декларативно. Это помогает сохранить ваш код DRY и декларативность.

Подсказка
Guards выполняются после всего промежуточного ПО, но до любого перехватчика или конвейера.

Authorization guard#
Как уже упоминалось, авторизация — отличный вариант использования Guard, поскольку определенные маршруты должны
быть доступны только тогда, когда вызывающий (обычно определенный аутентифицированный пользователь) имеет достаточные
разрешения. AuthGuard, который мы сейчас создадим, предполагает аутентифицированного пользователя
(и, следовательно, токен прикреплен к заголовкам запроса).
Он извлечет и проверит токен и будет использовать извлеченную информацию для определения того, может ли запрос
быть продолжен или нет.

import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request = context.switchToHttp().getRequest();
    return validateRequest(request);
  }
}

Подсказка
Если вы ищете реальный пример того, как реализовать механизм аутентификации в вашем приложении, посетите эту главу.
Аналогично, для более сложного примера авторизации посетите эту страницу.
Логика внутри функции validateRequest() может быть настолько простой или сложной, насколько это необходимо.
Основная цель этого примера — показать, как защитные функции вписываются в цикл запроса/ответа.

Каждый защитный функции должен реализовать функцию canActivate(). Эта функция должна возвращать логическое значение,
указывающее, разрешен ли текущий запрос или нет. Она может возвращать ответ как синхронно,
так и асинхронно (через Promise или Observable). Nest использует возвращаемое значение для управления следующим
действием:

-если оно возвращает true, запрос будет обработан.

-если оно возвращает false, Nest отклонит запрос.

Контекст выполнения#
Функция canActivate() принимает один аргумент, экземпляр ExecutionContext. ExecutionContext наследуется от ArgumentsHost.
Мы уже видели ArgumentsHost в главе о фильтрах исключений. В примере выше мы просто используем те же вспомогательные
методы, определенные в ArgumentsHost, которые мы использовали ранее, чтобы получить ссылку на объект Request.
Вы можете вернуться к разделу Arguments host главы о фильтрах исключений для получения дополнительной информации
по этой теме.

Расширяя ArgumentsHost, ExecutionContext также добавляет несколько новых вспомогательных методов,
которые предоставляют дополнительные сведения о текущем процессе выполнения.
Эти сведения могут быть полезны для создания более общих защит, которые могут работать в широком наборе контроллеров,
методов и контекстов выполнения.

Аутентификация на основе ролей#
Давайте создадим более функциональную защиту, которая разрешает доступ только пользователям с определенной ролью.
Мы начнем с базового шаблона защиты и будем развивать его в следующих разделах.
На данный момент он разрешает обработку всех запросов:

import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    return true;
  }
}

Связывающие защитные элементы#
Как и каналы и фильтры исключений, защитные элементы могут быть в области контроллера,
области метода или в глобальной области. Ниже мы настраиваем защитные элементы в области контроллера с
помощью декоратора @UseGuards(). Этот декоратор может принимать один аргумент или список аргументов,
разделенных запятыми. Это позволяет вам легко применять соответствующий набор защитных элементов с помощью
одного объявления.

@Controller('cats')
@UseGuards(RolesGuard)
export class CatsController {}

Подсказка
Декоратор @UseGuards() импортируется из пакета @nestjs/common.
Выше мы передали класс RolesGuard (вместо экземпляра), оставив ответственность за создание экземпляра
фреймворку и включив внедрение зависимостей. Как и в случае с каналами и фильтрами исключений,
мы также можем передать экземпляр на месте:

@Controller('cats')
@UseGuards(new RolesGuard())
export class CatsController {}

Конструкция выше прикрепляет охрану к каждому обработчику, объявленному этим контроллером.
Если мы хотим, чтобы охрана применялась только к одному методу, мы применяем декоратор @UseGuards() на уровне метода.

Чтобы настроить глобальную охрану, используйте метод useGlobalGuards() экземпляра приложения Nest:

const app = await NestFactory.create(AppModule);
app.useGlobalGuards(new RolesGuard());

Примечание
В случае гибридных приложений метод useGlobalGuards() не устанавливает защитные функции для шлюзов и микросервисов
по умолчанию (см. раздел Гибридное приложение для получения информации о том, как изменить это поведение).
Для «стандартных» (негибридных) приложений микросервисов useGlobalGuards() монтирует защитные функции глобально.
Глобальные защитные функции используются во всем приложении, для каждого контроллера и каждого обработчика маршрутов.
С точки зрения внедрения зависимостей глобальные защитные функции, зарегистрированные извне любого
модуля (с помощью useGlobalGuards(), как в примере выше), не могут внедрять зависимости,
поскольку это делается вне контекста любого модуля. Чтобы решить эту проблему, вы можете настроить защитные
функции напрямую из любого модуля, используя следующую конструкцию:

import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';

@Module({
  providers: [
    {
      provide: APP_GUARD,
      useClass: RolesGuard,
    },
  ],
})
export class AppModule {}

Подсказка
При использовании этого подхода для выполнения внедрения зависимости для сторожа, обратите внимание,
что независимо от модуля, где используется эта конструкция, сторож фактически является глобальным.
Где это следует делать? Выберите модуль, в котором определен сторож (RolesGuard в примере выше).
Кроме того, useClass — не единственный способ работы с регистрацией настраиваемого поставщика.

Установка ролей для обработчика#
Наш RolesGuard работает, но пока не очень умный. Мы пока не используем самую важную функцию сторожа — контекст выполнения.
Он еще не знает о ролях или о том, какие роли разрешены для каждого обработчика. Например, CatsController может
иметь разные схемы разрешений для разных маршрутов. Некоторые могут быть доступны только для пользователя-администратора,
а другие могут быть открыты для всех. Как мы можем сопоставить роли с маршрутами гибким и многоразовым способом?

Здесь в игру вступают пользовательские метаданные (узнайте больше здесь). Nest предоставляет возможность прикреплять
пользовательские метаданные к обработчикам маршрутов либо через декораторы, созданные с помощью статического
метода Reflector#createDecorator, либо через встроенный декоратор @SetMetadata().

Например, давайте создадим декоратор @Roles() с помощью метода Reflector#createDecorator, который прикрепит
метаданные к обработчику. Reflector предоставляется фреймворком из коробки и доступен из пакета @nestjs/core.

import { Reflector } from '@nestjs/core';

export const Roles = Reflector.createDecorator<string[]>();

Декоратор Roles здесь — это функция, которая принимает один аргумент типа string[].

Теперь, чтобы использовать этот декоратор, мы просто аннотируем обработчик им:

@Post()
@Roles(['admin'])
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}

Здесь мы прикрепили метаданные декоратора Roles к методу create(), указав, что доступ к этому маршруту должен
быть разрешен только пользователям с ролью администратора.

В качестве альтернативы, вместо использования метода Reflector#createDecorator, мы могли бы использовать встроенный
декоратор @SetMetadata().

Собираем все вместе#
Давайте теперь вернемся и свяжем это с нашим RolesGuard. В настоящее время он просто возвращает true во всех случаях,
позволяя каждому запросу продолжаться. Мы хотим сделать возвращаемое значение условным на основе сравнения ролей,
назначенных текущему пользователю, с фактическими ролями, требуемыми текущим обрабатываемым маршрутом.
Чтобы получить доступ к ролям маршрута (пользовательским метаданным), мы снова воспользуемся вспомогательным
классом Reflector, как показано ниже:


import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Roles } from './roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const roles = this.reflector.get(Roles, context.getHandler());
    if (!roles) {
      return true;
    }
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    return matchRoles(roles, user.roles);
  }
}

Подсказка
В мире node.js общепринятой практикой является присоединение авторизованного пользователя к объекту запроса.
Таким образом, в нашем примере кода выше мы предполагаем, что request.user содержит экземпляр пользователя и
разрешенные роли. В вашем приложении вы, вероятно, создадите эту связь в вашем пользовательском защитнике
аутентификации (или промежуточном программном обеспечении). Проверьте эту главу для получения дополнительной
информации по этой теме.
Предупреждение
Логика внутри функции matchRoles() может быть настолько простой или сложной, насколько это необходимо.
Основная цель этого примера — показать, как защитник вписывается в цикл запроса/ответа.
Подробнее об использовании Reflector с учетом контекста см. в разделе «Отражение и метаданные»
главы «Контекст выполнения».

Когда пользователь с недостаточными привилегиями запрашивает конечную точку, Nest автоматически возвращает
следующий ответ:

{
  "statusCode": 403,
  "message": "Forbidden resource",
  "error": "Forbidden"
}

Обратите внимание, что за кулисами, когда guard возвращает false, фреймворк выдает ForbiddenException.
Если вы хотите вернуть другой ответ об ошибке, вам следует выдать свое собственное исключение. Например:

throw new UnauthorizedException();

Любое исключение, выданное охраной, будет обработано слоем исключений (глобальный фильтр исключений и любые
фильтры исключений, которые применяются к текущему контексту).

Подсказка
Если вы ищете реальный пример того, как реализовать авторизацию,
проверьте эту главу (https://docs.nestjs.com/security/authorization).
